{
    "HumanEval/0": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        length = random.randint(2, 10)\n        numbers = [random.uniform(0, 10) for _ in range(length)]\n        threshold = random.uniform(0.1, 1.0)\n        base.append((numbers, threshold))\n    \n    # Corner test cases\n    for _ in range(25):\n        # Extremely close elements just under the threshold\n        length = random.randint(2, 5)\n        threshold = random.uniform(0.01, 0.05)\n        numbers = [random.uniform(1, 10)] * length\n        numbers = [num + random.uniform(-threshold/2, threshold/2) for num in numbers]\n        corner.append((numbers, threshold))\n        \n        # Identical elements with a small threshold\n        number = random.uniform(0, 10)\n        numbers = [number, number]\n        corner.append((numbers, 0.01))\n        \n        # Non-close elements with a high threshold\n        numbers = [0, 10, 20, 30, 40]\n        threshold = 9\n        corner.append((numbers, threshold))\n        \n    # Time complexity test cases\n    for _ in range(25):\n        # Large number of elements\n        length = 1000\n        numbers = [random.uniform(0, 1000) for _ in range(length)]\n        threshold = random.uniform(0.1, 10)\n        time.append((numbers, threshold))\n\n    # Space complexity test cases\n    for _ in range(25):\n        # Large numbers with significant decimal places\n        length = 10\n        numbers = [random.uniform(-1e6, 1e6) for _ in range(length)]\n        threshold = random.uniform(1e-5, 1e-3)\n        space.append((numbers, threshold))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/1": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Helper function to generate balanced parentheses string with nested levels\n    def generate_balanced_parentheses(n: int) -> str:\n        if n == 0:\n            return ''\n        mid = n // 2\n        return '(' + generate_balanced_parentheses(mid) + ')' + generate_balanced_parentheses(n - mid - 1)\n\n    # Base cases: simple and straightforward cases\n    for _ in range(25):\n        # Just a single pair of parentheses\n        base.append(\"()\")\n        # Two pairs of parentheses\n        base.append(\"(())\")\n        # Nested parentheses with space\n        base.append(\"( ( ) )\")\n        # Multiple single pairs\n        base.append(\"() () ()\")\n\n    # Corner cases: edge cases with minimal nesting or largest possible groups\n    for _ in range(25):\n        # Single but deep nested parentheses\n        corner.append(generate_balanced_parentheses(50).replace(\" \", \"\"))\n        # Multiple groups with maximum nesting in one group\n        corner.append(generate_balanced_parentheses(45) + \" \" + generate_balanced_parentheses(5))\n        # Max nesting and max group side by side\n        corner.append(generate_balanced_parentheses(25) + \" \" + generate_balanced_parentheses(25))\n        # Very close multiple groups\n        corner.append(\"()\"*25)\n\n    # Time complexity cases: cases intended to test the performance under timing constraints\n    for _ in range(25):\n        # Large number of groups\n        time.append(\"() \"*50)\n        # Nested groups spaced out\n        time.append(\"(\" * 50 + \")\" * 50)\n        # Alternating pattern with high count\n        time.append(\"(()())\" * 50)\n        # Progressive nesting\n        time.append(generate_balanced_parentheses(100))\n\n    # Space complexity cases: cases intended to test the memory usage and management\n    for _ in range(25):\n        # Very deeply nested single group\n        space.append(\"(\" * 500 + \")\" * 500)\n        # Very large number of small groups\n        space.append(\"() \" * 1000)\n        # Combination of deep and broad structures\n        space.append(generate_balanced_parentheses(250) + \" \" + generate_balanced_parentheses(250))\n        # Varying levels of nesting across many groups\n        space.append(\"(()) \" * 500)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/10": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base test cases\n    for _ in range(25):\n        base_length = random.randint(1, 50)\n        base_string = ''.join(random.choices(string.ascii_letters + string.digits, k=base_length))\n        if random.choice([True, False]):\n            # Creating a palindrome to ensure it is a valid base case\n            base_string = base_string + base_string[::-1]\n        base.append(base_string)\n\n    # Generating corner test cases\n    corner.append('')  # empty string, a valid palindrome\n    corner.append('a')  # single character, a palindrome\n    for _ in range(23):\n        corner_length = random.randint(0, 2)\n        corner_string = ''.join(random.choices(string.ascii_letters + string.digits, k=corner_length))\n        if random.choice([True, False]):\n            corner_string = corner_string + corner_string[::-1]\n        corner.append(corner_string)\n\n    # Generating time test cases (stress tests with longer input strings)\n    for _ in range(25):\n        time_length = random.randint(900, 1000)\n        time_string = ''.join(random.choices(string.ascii_letters + string.digits, k=time_length))\n        time.append(time_string)\n\n    # Generating space test cases (varied input types to stress memory handling)\n    for _ in range(25):\n        space_length = random.randint(1, 1000)\n        space_string = ''.join(random.choices(string.ascii_letters + string.digits, k=space_length))\n        # Occasionally reverse halfway to make nearly palindromic strings\n        if random.choice([True, False]):\n            mid = len(space_string) // 2\n            space_string = space_string[:mid] + space_string[mid:][::-1]\n        space.append(space_string)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/100": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases\n    for i in range(1, 26):\n        base.append(i)\n    \n    # Corner cases\n    corner.append(1)  # The minimum limit\n    for i in range(50, 75):\n        corner.append(i)\n    \n    # Time complexity cases\n    for i in range(1000, 1100):\n        time.append(i)\n    \n    # Space complexity cases\n    for i in range(10**6, 10**6 + 25):\n        space.append(i)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/101": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Helper to create random strings\n    def random_string(length: int, chars: str = string.ascii_letters + ' ,') -> str:\n        return ''.join(random.choice(chars) for _ in range(length))\n    \n    # Generate base cases\n    for _ in range(25):\n        s = random_string(random.randint(1, 20))\n        base.append(s)\n    \n    # Generate corner cases\n    corner.append(\"\")  # empty string should be avoided by constraints\n    for _ in range(1, 25):\n        s = random_string(1)  # single character strings\n        corner.append(s)\n    \n    # Generate time complexity cases\n    for _ in range(25):\n        s = random_string(random.randint(1000, 2000))\n        time.append(s)\n    \n    # Generate space complexity cases\n    for _ in range(25):\n        s = random_string(random.randint(500, 1000))\n        space.append(s)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/102": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: simple and direct cases\n    for i in range(1, 26):\n        x = i * 10\n        y = i * 10 + 5\n        base.append((x, y))\n\n    # Corner cases: edge values and reverse range\n    for i in range(1, 26):\n        x = 1 if i % 5 == 0 else i\n        y = 1 if i % 5 == 0 else i - 1\n        corner.append((x, y))\n        corner.append((x, x))  # Same value for x and y\n        corner.append((y, x))  # Reverse range for x and y\n\n    # Time complexity cases: Large ranges to potentially stress test the loop\n    for i in range(1, 26):\n        x = 1 + i\n        y = 1000000 + i\n        time.append((x, y))\n\n    # Space complexity cases: High values to test space allocation and handling\n    for i in range(1, 26):\n        x = 1000000 * i\n        y = 1000000 * i + 1000\n        space.append((x, y))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/103": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    import random\n    \n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases: Basic valid inputs within a reasonable range\n    for _ in range(25):\n        n = random.randint(1, 100)\n        m = random.randint(n, n + 100)  # Ensuring n is less than or equal to m\n        base.append((n, m))\n\n    # Corner Test Cases: Edge cases to test boundary conditions\n    for _ in range(25):\n        # Minimum possible values within the constraint\n        corner.append((1, 1))\n\n        # Sequential inputs with m just 1 more than n to test the rounding and conversion logic\n        n = random.randint(2, 1000)\n        m = n + 1\n        corner.append((n, m))\n\n        # Large values but still ensuring n < m\n        n = random.randint(1, 10000)\n        m = n + random.randint(1, 10000)\n        corner.append((n, m))\n\n        # Generating n > m scenario, which should return -1 according to the task\n        n = random.randint(10, 100)\n        m = random.randint(1, 9)\n        corner.append((n, m))\n\n    # Time Complexity Test Cases: High number inputs to test performance under load\n    for _ in range(25):\n        n = random.randint(100000, 200000)\n        m = random.randint(n, n + 100000)\n        time.append((n, m))\n\n    # Space Complexity Test Cases: Extremely high range inputs to test memory and computational limits\n    for _ in range(25):\n        n = random.randint(10**6, 2*10**6)\n        m = random.randint(n, n + 10**6)\n        space.append((n, m))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/104": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases\n    for _ in range(25):\n        size = random.randint(1, 10)  # length of the list from 1 to 10\n        test_case = [random.randint(1, 9999) for _ in range(size)]\n        base.append(test_case)\n\n    # Generate corner test cases\n    for _ in range(25):\n        # All odd numbers\n        test_case_odd = [random.choice([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]) for _ in range(10)]\n        # All even numbers\n        test_case_even = [random.choice([2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24]) for _ in range(10)]\n        # Combination of odd and even\n        mix = test_case_odd + test_case_even\n        random.shuffle(mix)\n        corner.append(mix)\n\n    # Generate time-complexity-focused test cases\n    for _ in range(25):\n        size = random.randint(100, 1000)  # larger list for time complexity testing\n        # Include mainly large integers to test performance\n        large_int_test_case = [random.randint(1, 999999) for _ in range(size)]\n        time.append(large_int_test_case)\n\n    # Generate space-complexity-focused test cases\n    for _ in range(25):\n        size = random.randint(50, 100)  # moderately large, but less than time complexity cases\n        # Integers focusing on space consumption, using a range that causes larger memory usage\n        moderate_int_test_case = [random.randint(1, 99999) for _ in range(size)]\n        space.append(moderate_int_test_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/105": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    # Arrays with only values from 1 to 9\n    for i in range(25):\n        length = random.randint(1, 10)  # Length between 1 and 10\n        test_case = [random.randint(1, 9) for _ in range(length)]\n        base.append(test_case)\n    \n    # Corner Test Cases\n    # Arrays that include boundary values like 0 and 10, or negative and huge numbers to make sure they're ignored\n    for i in range(25):\n        length = random.randint(1, 10)\n        test_case = [random.randint(1, 9) for _ in range(length - 2)]\n        test_case += [0, 10]  # Boundary values\n        random.shuffle(test_case)\n        corner.append(test_case)\n\n    # Time Complexity Test Cases\n    # Very large arrays of size ~1000 with valid range\n    for i in range(25):\n        length = 1000\n        test_case = [random.randint(1, 9) for _ in range(length)]\n        time.append(test_case)\n\n    # Space Complexity Test Cases\n    # Arrays containing just a few elements but repeated many times to test handling of large outputs\n    for i in range(25):\n        base_elem = random.randint(1, 9)\n        test_case = [base_elem] * 1000  # repeat the same element 1000 times\n        space.append(test_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/106": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for i in range(25):\n        n = random.randint(1, 10)  # Typical small sizes for n\n        base.append(n)\n    \n    # Corner cases\n    corner.append(0)  # Boundary at the minimum value of n\n    corner.append(25)  # Maximum reasonable n by given constraints\n    for i in range(23):\n        corner.append(random.randint(23, 25))  # Test boundary values just below the constraint\n\n    # Time complexity test cases\n    for i in range(25):\n        n = random.randint(10, 25)  # Higher values of n to test time complexity\n        time.append(n)\n\n    # Space complexity test cases\n    for i in range(25):\n        n = random.randint(10, 25)  # Larger values of n to test space usage\n        space.append(n)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/107": [
        "# Import statements\nfrom typing import Tuple, List, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Generating simple and typical inputs\n    for _ in range(25):\n        n = random.randint(1, 50)  # Smaller range for base testing\n        base.append(n)\n        \n    # Corner cases: Testing edge values and near boundary conditions\n    corner.append(1)          # Minimum limit\n    corner.append(1000)       # Maximum limit\n    for _ in range(23):\n        n = random.randint(990, 1000)  # Close to the upper boundary\n        corner.append(n)\n\n    # Time complexity cases: Larger values to check how the approach handles maximum constraints\n    for _ in range(25):\n        n = random.randint(900, 1000)  # Using the upper fourth of the limit\n        time.append(n)\n\n    # Space complexity cases: Values chosen to produce a large variety of numbers\n    for _ in range(25):\n        n = random.randint(1, 1000)  # Full range to check space utilization\n        space.append(n)\n        \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/108": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        # Include arrays with lengths varying from 0 to 10, with small range integers\n        length = random.randint(0, 10)\n        case = [random.randint(-9, 9) for _ in range(length)]\n        base.append(case)\n\n    # Corner test cases\n    for _ in range(25):\n        # Include edge cases such as maximum int, minimum int, and zeros\n        case = [random.choice([random.randint(-999, -990), random.randint(990, 999), 0]) for _ in range(25)]\n        corner.append(case)\n\n    # Time complexity test cases\n    for _ in range(25):\n        # Include large arrays with medium range integers to stress test\n        length = random.randint(50, 100)\n        case = [random.randint(-500, 500) for _ in range(length)]\n        time.append(case)\n\n    # Space complexity test cases\n    for _ in range(25):\n        # Test with arrays of varied large sizes containing small range integers\n        length = random.randint(50, 200)\n        case = [random.randint(-10, 10) for _ in range(length)]\n        space.append(case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/109": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # Small and manageable size for base cases\n        array = random.sample(range(-100, 100), length)  # Ensure unique elements\n        base.append(array)\n\n    # Corner test cases\n    # Including cases with the smallest and largest possible arrays\n    corner.append([])  # Case with zero elements\n    corner.append([1])  # Case with one element\n    corner.append([2, 1])  # Case where single operation needed\n    corner.append([3, 1, 2])  # Case where one right shift results in sorted array\n    corner.append([1, 3, 2])  # Case where it's not possible to sort via shifts\n\n    while len(corner) < 25:\n        length = random.randint(1, 10)\n        array = random.sample(range(-1000, 1000), length)\n        if array not in corner:\n            corner.append(array)\n\n    # Time complexity test cases\n    # Creating large arrays to test the time performance\n    for _ in range(25):\n        length = random.randint(9500, 10000)  # Close to the upper limit\n        array = random.sample(range(-50000, 50000), length)\n        time.append(array)\n\n    # Space complexity test cases\n    # Large arrays to potentially test memory usage\n    for _ in range(25):\n        length = random.randint(8000, 10000)  # Also large for space complexity\n        array = random.sample(range(-100000, 100000), length)\n        space.append(array)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/11": [
        "# Import statements\nfrom typing import List, Tuple\nfrom random import randint, choice\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]]]:\n    base, corner, time, space = [], [], [], []\n\n    # Some helper functions to generate random binary strings\n    def random_binary_string(length: int) -> str:\n        return ''.join(choice('01') for _ in range(length))\n    \n    # Base cases: Normal use cases\n    for _ in range(25):\n        len_str = randint(1, 10)  # reasonable length to check XOR\n        str_a = random_binary_string(len_str)\n        str_b = random_binary_string(len_str)\n        base.append((str_a, str_b))\n\n    # Corner cases: Edge conditions\n    corner.append((\"0\", \"0\"))\n    corner.append((\"1\", \"1\"))\n    corner.append((\"0\"*500, \"0\"*500))  # Large same strings\n    corner.append((\"1\"*500, \"1\"*500))  # Large same strings\n    for _ in range(21):  # Additional cases to make 25\n        len_str = 1  # smallest possible non-trivial case\n        str_a = random_binary_string(len_str)\n        str_b = random_binary_string(len_str)\n        corner.append((str_a, str_b))\n    \n    # Time complexity cases: Large inputs to test performance\n    for _ in range(25):\n        len_str = randint(1000, 5000)  # large length for time complexity\n        str_a = random_binary_string(len_str)\n        str_b = random_binary_string(len_str)\n        time.append((str_a, str_b))\n    \n    # Space complexity cases: Large but fewer cases\n    for _ in range(25):\n        len_str = randint(500, 1000)  # large enough to challenge space usage\n        str_a = random_binary_string(len_str)\n        str_b = random_binary_string(len_str)\n        space.append((str_a, str_b))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/110": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # BASE CASES\n    # Generate balanced lists of even and odd numbers\n    for _ in range(25):\n        even_numbers = [x * 2 for x in range(10)]  # A list of 10 even numbers\n        odd_numbers = [x * 2 + 1 for x in range(10)]  # A list of 10 odd numbers\n        random.shuffle(even_numbers)\n        random.shuffle(odd_numbers)\n        base.append((odd_numbers[:5] + even_numbers[:5], even_numbers[5:] + odd_numbers[5:]))\n\n    # CORNER CASES\n    # Small lists with various distributions of evens and odds\n    corner.append(([1], [2]))  # Minimum required lists to get a YES\n    corner.append(([2], [1]))  # Minimum required lists to still get a NO due to already even lst1\n    corner.append(([1, 3, 5], [2, 4, 6]))  # Exactly matching odd in lst1 with even in lst2\n    corner.append(([1, 3, 5], [2, 4]))  # Insufficient evens in lst2\n\n    # Adding more to cover 25 cases with various odd few scenarios\n    for i in range(21):\n        lst1 = [random.randint(1, 100) for _ in range(random.randint(1, 5))]\n        lst2 = [random.randint(1, 100) for _ in range(random.randint(1, 5))]\n        corner.append((lst1, lst2))\n\n    # TIME CASES\n    # Large lists that push the limits of execution time boundaries\n    for _ in range(25):\n        lst1 = [random.randint(1, 10) * random.choice([1, 2]) for _ in range(5000)]\n        lst2 = [random.randint(1, 10) * random.choice([1, 2]) for _ in range(5000)]\n        time.append((lst1, lst2))\n\n    # SPACE CASES\n    # Large but sparse arrays that focus on memory usage\n    for _ in range(25):\n        lst1 = [random.choice([random.randint(1, 100) * 2 + 1, random.randint(1, 100) * 2]) for _ in range(1000)]\n        lst2 = [random.choice([random.randint(1, 100) * 2, random.randint(1, 100) * 2 + 1]) for _ in range(1000)]\n        space.append((lst1, lst2))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/111": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases (simple and straightforward cases)\n    base.append(\"a b c a b\")  # Expected {'a': 2, 'b': 2}\n    base.append(\"b b b b a\")  # Expected {'b': 4}\n    base.append(\"z\")          # Expected {'z': 1}\n    base.append(\"a z z z z a a\")  # Expected {'z': 4, 'a': 3}\n    while len(base) < 25:\n        letters = random.choices(string.ascii_lowercase + ' ', k=random.randint(1, 50))\n        test_case = ' '.join(letters).strip()\n        base.append(test_case)\n    \n    # Generate corner test cases (edge cases)\n    corner.append(\"\")  # Empty string\n    corner.append(\"a\" * 1000)  # Long string of a single letter\n    corner.append(\"a \" * 500)  # Long string of a letter and a space\n    corner.append(\"a \" * 500 + \"b\" * 500)  # Edge case with two letters\n    while len(corner) < 25:\n        letters = random.choices(string.ascii_lowercase, k=random.randint(1, 3))\n        repeated_string = (' '.join(letters) + ' ') * random.randint(300, 333)\n        corner.append(repeated_string.strip())\n    \n    # Generate time complexity test cases (stress tests with large input size)\n    for _ in range(25):\n        letters = random.choices(string.ascii_lowercase + ' ', k=1000)\n        test_case = ' '.join(letters).strip()\n        time.append(test_case)\n\n    # Generate space complexity test cases (stress tests focusing on input size and unique elements)\n    for _ in range(25):\n        unique_letters = random.sample(string.ascii_lowercase, k=26)  # All unique letters\n        random.shuffle(unique_letters)\n        test_case = ' '.join(unique_letters * random.randint(1, 10))\n        space.append(test_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/112": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        length_s = random.randint(1, 50)  # Reasonable length for base cases\n        length_c = random.randint(1, length_s)  # Ensure c is not longer than s\n        s = ''.join(random.choices(string.ascii_lowercase, k=length_s))\n        c = ''.join(random.sample(s, k=length_c))  # Ensure all chars of c are in s\n        base.append((s, c))\n\n    # Corner Cases\n    # Case 1: Single character strings\n    corner.append(('a', 'a'))\n    corner.append(('a', 'b'))\n    # Case 2: c contains all characters of s\n    s = 'abcdef'\n    c = 'abcdef'\n    corner.append((s, c))\n    # Case 3: c is empty\n    s = 'abcdef'\n    c = ''\n    corner.append((s, c))\n    # Case 4: s is already a palindrome\n    s = 'racecar'\n    c = 'r'\n    corner.append((s, c))\n    \n    # Extend to 25 corner cases\n    while len(corner) < 25:\n        length = random.randint(1, 10)  # Smaller lengths for visibility in corner cases\n        s = ''.join(random.choices(string.ascii_lowercase, k=length))\n        c = ''.join(random.sample(s, k=min(len(s), random.randint(1, len(s)))))\n        corner.append((s, c))\n\n    # Time Complexity Cases\n    for _ in range(25):\n        length_s = 1000  # Max length for stress testing time complexity\n        length_c = random.randint(1, length_s)\n        s = ''.join(random.choices(string.ascii_lowercase, k=length_s))\n        c = ''.join(random.sample(s, k=length_c))\n        time.append((s, c))\n\n    # Space Complexity Cases\n    for _ in range(25):\n        length_s = 1000  # Max length for stress testing space complexity\n        length_c = random.randint(1, length_s)\n        s = ''.join(random.choices(string.ascii_lowercase, k=length_s))\n        c = ''.join(random.sample(s, k=length_c))\n        space.append((s, c))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/113": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for i in range(25):\n        # Generate lists of strings where each string is a single digit (0-9)\n        base_case = [str(random.randint(0, 9)) for _ in range(random.randint(1, 10))]\n        base.append(base_case)\n    \n    # Corner Cases\n    for i in range(25):\n        if i < 13:\n            # All zeroes\n            corner_case = ['0' * random.randint(1, 10) for _ in range(random.randint(1, 10))]\n        else:\n            # All nines\n            corner_case = ['9' * random.randint(1, 10) for _ in range(random.randint(1, 10))]\n        corner.append(corner_case)\n    \n    # Time Complexity Cases\n    for i in range(25):\n        # Create very large lists up to 100 elements\n        time_case = [str(random.randint(0, 9)) for _ in range(100)]\n        time.append(time_case)\n    \n    # Space Complexity Cases\n    for i in range(25):\n        # Long strings up to 100 digits\n        space_case = [str(random.randint(0, 9)) * 100 for _ in range(random.randint(1, 10))]\n        space.append(space_case)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/114": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport sys\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    # Initial lists to hold each type of test case\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append([0] * 100)  # Large array of zeros\n    base.append([-1] * 70 + [1] * 30)  # Mixture of negative and positive numbers\n    base.append([random.randint(-100, 100) for _ in range(20)])  # Random small array\n    base.append([5] * 100)  # Large array of the same positive number\n    \n    # Corner cases\n    corner.append([sys.maxsize])  # Largest 32-bit integer\n    corner.append([-sys.maxsize - 1])  # Smallest 32-bit integer\n    corner.append([sys.maxsize, -sys.maxsize - 1])  # Edge integer values together\n    corner.append([-1, 2, -3, 4, -5])  # Alternating small positive and negative numbers\n    \n    # Time Complexity cases\n    for _ in range(25):\n        size = 1000  # High number of elements to test the function's time performance\n        time.append([random.randint(-1000, 1000) for _ in range(size)])\n    \n    # Space Complexity cases\n    for _ in range(25):\n        size = 500  # Medium size multiple times to test memory usage and manageability\n        space.append([random.randint(-500, 500) for _ in range(size)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/115": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport math\n\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    # simple example cases with varying grid sizes and capacities\n    base.append(([[1, 0], [0, 1]], 1))\n    base.append(([[0, 0, 1, 1], [1, 1, 0, 0]], 2))\n    base.append(([[0, 1, 1], [1, 0, 0], [0, 0, 1]], 3))\n    for _ in range(22):\n        r, c = random.randint(1, 5), random.randint(1, 5)\n        grid = [[random.randint(0, 1) for _ in range(c)] for _ in range(r)]\n        capacity = random.randint(1, 4)\n        base.append((grid, capacity))\n\n    # Corner cases\n    # minimal and extreme input values\n    corner.append(([[1] * 100], 1))  # All wells full in single row, minimal bucket size\n    corner.append(([[0] * 100], 10))  # All wells empty in single row, max bucket size\n    corner.append(([[1, 0] * 50], 10))  # Alternating full-empty wells, max bucket size\n    for _ in range(22):\n        r = random.randint(1, 3)\n        c = random.randint(95, 100)\n        grid = [[random.randint(0, 1) for _ in range(c)] for _ in range(r)]\n        capacity = random.randint(1, 10)\n        corner.append((grid, capacity))\n\n    # Time complexity cases\n    # Large grids to test the upper boundaries of time constraints\n    for _ in range(25):\n        r, c = random.randint(50, 100), random.randint(50, 100)\n        grid = [[random.randint(0, 1) for _ in range(c)] for _ in range(r)]\n        capacity = random.randint(1, 10)\n        time.append((grid, capacity))\n\n    # Space complexity cases\n    # Large grids to test spatial efficiency and memory usage\n    space.append(([[1, 0] * 50] * 100, 1))\n    space.append(([[0, 1] * 50] * 100, 10))\n    for _ in range(23):\n        r, c = random.randint(80, 100), random.randint(80, 100)\n        grid = [[random.randint(0, 1) for _ in range(c)] for _ in range(r)]\n        capacity = random.randint(1, 10)\n        space.append((grid, capacity))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/116": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append([1, 2, 3, 4, 5])  # Simple sorted list\n    base.append([5, 4, 3, 2, 1])  # Reverse sorted list\n    base.append([1, 3, 2, 5, 4])  # Mixed order list\n    base.append([0, 1])           # List containing zero\n    base.append([0])              # List containing only zero\n    \n    # Corner cases\n    corner.append([1])            # Single element\n    corner.append([])             # Empty list - might fail constraint if not handled properly\n    corner.append([2**10 - 1])    # Large binary value of ones\n    corner.append([2**15, 2**14]) # Large values checking\n    corner.append([0, 0, 0, 0])   # All zeros\n    \n    # Time cases\n    max_int = 2**20\n    for i in range(25):\n        time.append(sorted(random.sample(range(max_int), k=random.randint(5, 20)), key=lambda x: bin(x).count('1')))\n    \n    # Space cases\n    # Generating very large arrays with non-trivial binary representation\n    for i in range(25):\n        num_elements = random.randint(50, 100)\n        space.append([random.randint(0, max_int) for _ in range(num_elements)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/117": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Helper function to generate a random string with only letters and spaces\n    def random_string(max_length: int) -> str:\n        letters = string.ascii_letters + ' ' * 10  # more spaces to have some empty words potentially\n        return ''.join(random.choice(letters) for _ in range(random.randint(1, max_length)))\n\n    # Base cases\n    for _ in range(25):\n        n = random.randint(0, 10)  # reasonable range for n\n        s = random_string(100)  # strings of moderate length\n        base.append((s, n))\n    \n    # Corner cases\n    # Case 1: n is zero\n    for _ in range(10):\n        s = random_string(100)\n        corner.append((s, 0))\n    \n    # Case 2: Empty string\n    corner.append((\"\", random.randint(0, 10)))\n\n    # Case 3: Maximum n where no s can satisfy\n    corner.append((\"simple test run\", 20))\n\n    # Case 4: String with all consonants\n    corner.extend([\n        (\"bcdfghjklmnpqrstvwxyz\", n)\n        for n in range(5, 20, 3)  # varied range where some cases will be valid, some will not\n    ])\n    \n    # Time complexity cases\n    # Large input sizes for performance testing\n    for _ in range(50):\n        n = random.randint(0, 15)\n        s = random_string(5000)  # very long strings to challenge the time efficiency\n        time.append((s, n))\n\n    # Space complexity cases\n    # High number of words to challenge space utilization in results\n    for _ in range(50):\n        n = random.randint(0, 15)\n        words = [random_string(20) for _ in range(200)]  # lots of medium size words\n        s = ' '.join(words)\n        space.append((s, n))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/118": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases\n    base.append(\"yogurt\")  # General case with vowel between consonants\n    base.append(\"quick\")   # No vowel between consonants\n    base.append(\"FULL\")    # Upper case with vowel between consonants\n    base.append(\"abcde\")   # Vowel at the end, none in between consonants\n    base.append(\"zyz\")     # No vowels at all\n\n    # Corner cases\n    for _ in range(25):\n        # Single vowel surrounded by different pairs of consonants\n        consonants = ''.join(random.choice(string.ascii_letters.replace('aeiouAEIOU', '')) for _ in range(2))\n        vowel = random.choice('aeiouAEIOU')\n        corner.append(f\"{consonants[0]}{vowel}{consonants[1]}\")\n        \n    # Time complexity-related cases\n    for length in range(100, 101 + 25):\n        # Create long strings ensuring a single valid vowel between consonants\n        large_input = ''.join(random.choice(string.ascii_letters) for _ in range(length - 3))\n        # Ensure a valid position for a vowel between two consonants somewhere within the string\n        valid_pos = random.randint(1, len(large_input) - 1)\n        vowel = random.choice('aeiouAEIOU')\n        cons1 = random.choice(string.ascii_letters.replace('aeiouAEIOU', ''))\n        cons2 = random.choice(string.ascii_letters.replace('aeiouAEIOU', ''))\n        large_input = large_input[:valid_pos] + cons1 + vowel + cons2 + large_input[valid_pos:]\n        time.append(large_input)\n\n    # Space complexity-related cases\n    for _ in range(25):\n        # Create strings with many vowels but only one valid case\n        long_string = ''.join(random.choice('aeiou') * 10 for _ in range(10))\n        valid_consonants = random.choice(string.ascii_letters.replace('aeiouAEIOU', ''))\n        space.append(valid_consonants + long_string + valid_consonants)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/119": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[str]], List[List[str]], List[List[str]], List[List[str]]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case: Well-distributed cases of balanced and unbalanced parentheses\n    base = [\n        ['()', '()'],  # two simple good strings\n        ['()', ')('],  # one good, one bad when together\n        [')(', ')('],  # bad when together, but good when switched\n        [')())(', '((()'],  # unbalanced but can be balanced when switched\n        ['(((', ')))']  # perfect match when concatenated\n    ]\n\n    # Corner Cases: Extremes, minimal inputs, maximum imbalanced\n    corner = [\n        ['', ''],  # empty strings\n        ['(', ')'],  # minimal balancing strings\n        ['(', '('],  # minimal unbalanced\n        [')())', '(()()('], # balanced\n        [')()()()(()()))', '(('], # balanced\n        ['))))))))))))))))))', '((((((((((((((((((('],  # many parentheses, but balances when switched\n        ['(' * 1000, ')' * 1000],  # very large perfect balancing\n        [')' * 1000 + '(', '(' + ')' * 999]  # nearly balanced large strings\n    ]\n    \n    # Time Complexity Cases: Aimed at stressing the evaluator function\n    time = [[\"\".join(random.choices(['()', ')('], k=1000)), \"\".join(random.choices(['(', ')'], k=1000))] for _ in range(25)]\n\n    # Space Complexity Cases: Aimed at extreme memory usage\n    space = [[\"\".join(random.choices(['()', ')('], k=1000)), \"\".join(random.choices(['(', ')'], k=1000))] for _ in range(25)]\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/12": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    base.append(['a', 'b', 'c'])  # example provided in the task\n    base.append(['hello', 'world', 'python', 'code'])  # mixed length strings\n    base += [['cat'] * random.randint(1, 5) for _ in range(5)]  # repeating same word multiple times in different lengths\n\n    # Corner Cases\n    corner.append([])  # empty list case\n    corner.append(['same', 'same', 'same'])  # all strings of the same length\n    corner.append([random.choice(string.ascii_letters) for _ in range(100)])  # list of single-character strings\n    corner.append(['a' * 10000] * 2)  # list with very long strings\n\n    # Time Complexity Cases (focused on large datasets)\n    for _ in range(25):\n        time.append([''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(1, 1000))) for _ in range(random.randint(100, 500))])\n\n    # Space Complexity Cases (focused on very long strings)\n    for _ in range(25):\n        space.append([''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(10000, 20000))) for _ in range(random.randint(1, 10))])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/120": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append(([-3, -4, 5], 3))  # Example 1 from the task description\n    base.append(([4, -4, 4], 2))  # Example 2 from the task description\n    base.append(([-3, 2, 1, 2, -1, -2, 1], 1))  # Example 3 from the task description\n\n    # Corner cases\n    corner.append(([1], 1))  # Minimal input size\n    corner.append(([1000] * 1000, 1000))  # Maximum element size populating max array length\n    corner.append(([-1000, 1000], 2))  # Extreme element values\n    corner.append(([5], 0))  # k = 0 with minimal array size\n\n    # Time complexity cases (large inputs)\n    for _ in range(25):\n        # Generate arrays with max allowed size and varied elements\n        n = 1000\n        k = random.randint(1, n)\n        arr = [random.randint(-1000, 1000) for _ in range(n)]\n        time.append((arr, k))\n\n    # Space complexity cases (large k values)\n    for _ in range(25):\n        # Generate arrays with large k values close to array size\n        n = random.randint(1, 1000)\n        k = random.randint(n//2, n)  # Ensuring k is large relative to n\n        arr = [random.randint(-1000, 1000) for _ in range(n)]\n        space.append((arr, k))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/121": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # moderate size list\n        lst = [random.randint(-100, 100) for _ in range(length)]\n        base.append(lst)\n    \n    # Corner cases\n    for _ in range(25):\n        # Create list with single odd element at even position\n        lst = [0] * random.randint(2, 5)\n        lst[0] = random.choice([x for x in range(-100, 100) if x % 2 != 0])\n        corner.append(lst)\n    \n    # Time complexity cases\n    for _ in range(25):\n        length = random.randint(1000, 2000)  # very large list to test time performance\n        lst = [random.randint(-1000, 1000) for _ in range(length)]\n        time.append(lst)\n    \n    # Space complexity cases\n    for _ in range(25):\n        length = random.randint(500, 1000)  # large list to test space/memory usage\n        lst = [random.randint(-500, 500) for _ in range(length)]\n        space.append(lst)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/122": [
        "# Import statements\nfrom typing import Tuple, List, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base cases\n    for _ in range(25):\n        n = random.randint(1, 100)\n        k = random.randint(1, n)\n        arr = [random.randint(1, 99) for _ in range(n)]\n        base.append((arr, k))\n\n    # Generating corner cases\n    for _ in range(25):\n        # Edge cases for k = 1 and k = len(arr)\n        n = random.randint(1, 100)\n        edges = [1, n]\n        for k in edges:\n            arr = [random.randint(-99, 999) for _ in range(n)]\n            corner.append((arr, k))\n\n    # Generating time complexity cases\n    for _ in range(25):\n        n = 100  # maximize array length for stress tests\n        k = random.randint(1, n)\n        arr = [random.randint(-999, 999) for _ in range(n)]\n        time.append((arr, k))\n\n    # Generating space complexity cases\n    for _ in range(25):\n        n = random.randint(50, 100)  # higher range to potentially use more space\n        k = random.randint(1, n)\n        # Include large numbers to see how well the memory handling is (although it won't affect much in Python)\n        arr = [random.randint(-10**6, 10**6) for _ in range(n)]\n        space.append((arr, k))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/123": [
        "from typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    # These are simple cases to test normal operation\n    base_cases = [1, 2, 3, 4, 5, 10, 15, 20, 25, 50]\n    base.extend(base_cases)\n\n    # Corner Cases\n    # These are edge values or peculiar values that might trigger errors\n    corner.extend([1, 1000000, 999999, 1001, 2023])  # 1 is the minimum edge, large values test integers at high bounds\n\n    # Time Complexity Cases\n    # Large numbers to test the time it takes for the function to execute\n    for _ in range(25):\n        time.append(random.randint(100000, 10000000))\n\n    # Space Complexity Cases\n    # Similar to time, but focuses on how the function handles memory with large inputs\n    for _ in range(25):\n        space.append(random.randint(500000, 15000000))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/124": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for i in range(25):\n        month = random.randint(1, 12)\n        year = random.randint(1900, 2100)\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            day = random.randint(1, 31)\n        elif month in {4, 6, 9, 11}:\n            day = random.randint(1, 30)\n        elif month == 2:\n            day = random.randint(1, 29)\n        base.append(f\"{month:02d}-{day:02d}-{year}\")\n\n    # Corner test cases\n    # Minimum and maximum days and leap year considerations\n    for i in range(25):\n        if i % 4 == 0:  # Test February on non-leap year\n            month = 2\n            day = 29\n            year = 1901  # a non-leap year\n        elif i % 4 == 1:  # Test February on leap year\n            month = 2\n            day = 29\n            year = 2000  # a leap year\n        elif i % 4 == 2:  # Test a month with 30 days\n            month = 4\n            day = 30\n        else:  # Test a month with 31 days\n            month = 7\n            day = 31\n        \n        corner.append(f\"{month:02d}-{day:02d}-{year}\")\n\n    # Time complexity test cases (testing valid inputs)\n    for i in range(25):\n        month = random.randint(1, 12)\n        year = random.randint(1000, 9999)  # Testing with broader range of year\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            day = random.randint(1, 31)\n        elif month in {4, 6, 9, 11}:\n            day = random.randint(1, 30)\n        elif month == 2:\n            day = random.randint(1, 29)\n        time.append(f\"{month:02d}-{day:02d}-{year}\")\n\n    # Space complexity test cases (should be similar to time since it's input size dependent)\n    # Here we randomly shuffle the valid inputs\n    for i in range(25):\n        month = random.randint(1, 12)\n        year = random.randint(1000, 9999)  # Use a broader range of years\n        if month in {1, 3, 5, 7, 8, 10, 12}:\n            day = random.randint(1, 31)\n        elif month in {4, 6, 9, 11}:\n            day = random.randint(1, 30)\n        elif month == 2:\n            day = random.randint(1, 29)\n        space.append(f\"{month:02d}-{day:02d}-{year}\")\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/125": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    base.append(\"Hello world!\")  # Normal string with spaces\n    base.append(\"Hello,world!\")  # Normal string with comma\n    base.append(\"abcdef\")  # Normal string with letters only\n    for _ in range(22):\n        length = random.randint(1, 50)\n        s = ''.join(random.choices(string.ascii_letters + string.digits + ' ', k=length))\n        base.append(s)\n\n    # Corner Cases\n    corner.append(\" \")  # Single whitespace\n    corner.append(\",\")  # Single comma\n    corner.append(\"a\")  # Single lowercase letter\n    corner.append(\"A\")  # Single uppercase letter\n    corner.append(\"\")  # Empty string (Not valid under constraints, not added)\n    for _ in range(20):\n        chars = random.choice([',', ' '])\n        length = random.randint(1, 50)\n        s = chars * length\n        corner.append(s)\n\n    # Time Complexity Cases\n    for _ in range(25):\n        length = random.randint(1000, 10000)\n        s = ''.join(random.choices(string.ascii_letters + ',', k=length))\n        time.append(s)\n\n    # Space Complexity Cases\n    for _ in range(25):\n        length = random.randint(500, 1000)\n        s = ''.join(random.choices(string.ascii_letters + ' ' + ',', k=length))\n        space.append(s)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/126": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    base.append([1, 2, 3, 4, 5])  # simple sorted list with unique elements\n    base.append([5, 4, 3, 2, 1])  # simple non-sorted list with unique elements\n    base.append([1, 1, 2, 2, 3, 3])  # sorted with duplicates, but each no more than twice\n    base.append([2, 2, 2, 3, 3])  # contains triple duplication of an element\n\n    # Corner Cases\n    corner.append([])  # empty list\n    corner.append([1])  # single element list\n    corner.append([0, 0, 0, 0, 0])  # all elements are zero, exceeding allowed duplicates\n    corner.append([0, 0])  # all elements are zero, allowed duplicates\n\n    # Time Complexity Cases (For Large Inputs)\n    for i in range(25):\n        time.append(list(range(0, 10000, 2)) + list(range(10000, 0, -2)))  # large list, first half sorted, second half reverse sorted\n\n    # Space Complexity Cases (For Large and Edge Inputs)\n    for i in range(25):\n        space.append([1, 2] * 5000)  # exactly at the limit of duplication\n        space.append([3] * 6000 + [4] * 6000)  # chunks of duplicates, exceeding limits by large amounts\n\n    # Fill the remaining test cases to make min 25 each\n    for i in range(10):\n        base.append([i for i in range(20)])  # incrementing sorted small lists\n        corner.append([i % 3 for i in range(20)])  # small lists with repetitions at the border case of limits\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/127": [
        "# Import statements\nfrom typing import List, Tuple, Any\nfrom random import randint\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Simple and typical intervals\n    for _ in range(25):\n        start1 = randint(-100, 100)\n        end1 = randint(start1, start1 + 100)\n        start2 = randint(-100, 100)\n        end2 = randint(start2, start2 + 100)\n        base.append(((start1, end1), (start2, end2)))\n\n    # Corner cases: Extreme interval ends, zero-length intervals, and touching intervals\n    corner.append(((-10, -10), (-10, -10)))  # Zero-length intervals that touch\n    corner.append(((50, 50), (50, 100)))     # One zero-length at the start of another\n    corner.append(((100, 100), (-100, 99)))  # Zero-length interval just outside another\n    corner.append(((10, 100), (102, 200)))   # Non-overlapping intervals with gap\n    for _ in range(21):  # Additional variety of corner cases\n        start1 = randint(-10, 10)\n        end1 = start1\n        start2 = randint(-10, 10)\n        end2 = start2 if randint(0, 1) else start2 + randint(0, 10)\n        corner.append(((start1, end1), (start2, end2)))\n\n    # Time complexity cases: Very large intervals to potentially test performance\n    for _ in range(25):\n        start1 = randint(-1000000, 1000000)\n        end1 = start1 + randint(0, 2000000)\n        start2 = randint(-1000000, 1000000)\n        end2 = start2 + randint(0, 2000000)\n        time.append(((start1, end1), (start2, end2)))\n\n    # Space complexity cases: Intervals with a large range \n    for _ in range(25):\n        start1 = randint(-100000, 100000)\n        end1 = randint(start1 + 10000, start1 + 50000)\n        start2 = randint(-100000, 100000)\n        end2 = randint(start2 + 10000, start2 + 50000)\n        space.append(((start1, end1), (start2, end2)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/128": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: simple straightforward cases with small lists\n    base.append([1, -1, 2])  # Simple mixed signs\n    base.append([])  # Empty list\n    base.append([0])  # Single zero\n    base.append([100])  # Single positive number\n    base.append([-100])  # Single negative number\n    for _ in range(20):\n        size = random.randint(1, 5)  # Small size\n        base.append([random.randint(-10, 10) for _ in range(size)])\n\n    # Corner cases: focusing on edge scenarios\n    corner.append([1] * 25)  # All positive numbers\n    corner.append([-1] * 25)  # All negative numbers\n    corner.append([0] * 25)  # All zeros\n    corner.append([1, -1] * 12 + [1])  # Alternating signs\n    for _ in range(21):\n        size = random.randint(1, 10)\n        corner.append([random.choice([-1, 0, 1]) for _ in range(size)])  # Only -1, 0, 1\n\n    # Time complexity cases: large lists to test performance\n    time.append([1] * 100)  # Large list with repeated positive number\n    time.append([-1] * 100)  # Large list with repeated negative number\n    time.append([0] * 100)  # Large list with zeros\n    time.append([random.randint(-100, 100) for _ in range(100)])  # Large list with mixed numbers\n    for _ in range(21):\n        size = random.randint(50, 100)\n        time.append([random.randint(-1000, 1000) for _ in range(size)])\n\n    # Space complexity cases: to check memory usage\n    space.append([2, -2] * 50)  # Alternating small numbers\n    space.append([0] * 100)  # Large number of zeros\n    space.append([123456789, -123456789] * 50)  # Large magnitude numbers\n    space.append([1, -1, 0] * 33 + [1])  # Mixed trivial list repeated\n    for _ in range(21):\n        size = random.randint(25, 50)\n        space.append([random.choice([-100000, 0, 100000]) for _ in range(size)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/129": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for n in range(2, 6):  # Testing smaller grids\n        grid = [[n * i + j + 1 for j in range(n)] for i in range(n)]\n        k_values = [1, n, n * n]\n        for k in k_values:\n            base.append((grid, k))\n    \n    # Corner Cases\n    corner.append(([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1))\n    corner.append(([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 9))\n    corner.append(([[9, 8, 7], [6, 5, 4], [3, 2, 1]], 3))\n    corner.append(([[2, 3, 4], [5, 6, 7], [8, 9, 1]], 5))\n    corner.append(([[2, 3, 4], [5, 6, 7], [8, 9, 1]], 13))\n\n    n = 2\n    k_corner = [1, 2, 3, 4]\n    grids_corner = [\n        [[1, 2], [4, 3]],\n        [[2, 1], [3, 4]],\n        [[4, 1], [2, 3]],\n        [[3, 4], [1, 2]]\n    ]\n    for grid in grids_corner:\n        for k in k_corner:\n            corner.append((grid, k))\n    \n    # Time Complexity Cases (larger k values and grids)\n    for n in range(10, 15):  # Larger grids to test time complexity\n        grid = [[n * i + j + 1 for j in range(n)] for i in range(n)]\n        k_values = [n, n * 2, n * (n - 1)]  # High k values close to N*N\n        for k in k_values:\n            time.append((grid, k))\n    \n    # Space Complexity Cases (very high N values but low k values)\n    for n in range(15, 20):  # Even larger grids to test space complexity\n        grid = [[n * i + j + 1 for j in range(n)] for i in range(n)]\n        k_values = [1, 2, 3]  # Relatively small k values\n        for k in k_values:\n            space.append((grid, k))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/13": [
        "# Import statements\nfrom typing import List, Tuple, Any\nfrom random import randint\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append((1, 1))\n    base.append((0, 1))\n    base.append((1, 0))\n    base.append((12, 15))\n    for _ in range(21):\n        a = randint(1, 100)\n        b = randint(1, 100)\n        base.append((a, b))\n\n    # Corner cases\n    corner.append((1, int(1e9)))  # Test large number\n    corner.append((int(1e9), 1))  # Test large number\n    corner.append((-1, -1))  # Test negative numbers\n    corner.append((-1, 1))   # Test mixed signs\n    for _ in range(21):\n        a = randint(-1000, 0)\n        b = randint(1, 1000)\n        corner.append((a, b))\n\n    # Time complexity cases\n    for _ in range(25):\n        a = randint(1, int(1e9))\n        b = randint(1, int(1e9))\n        time.append((a, b))\n\n    # Space complexity cases\n    space.append((0, 1))  # Minimally small non-zero, edge of constraint\n    for _ in range(24):\n        a = randint(-int(1e9), int(1e9))\n        b = randint(-int(1e9), int(1e9))\n        if a == 0 and b == 0:\n            b = 1  # adjust to meet constraints if both a and b are zero\n        space.append((a, b))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/130": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases: Small, common inputs to verify basic functionality.\n    for i in range(1, 26):\n        base.append(i)  # Consecutive small positive integers\n\n    # Corner test cases: Extreme or unusual input values near boundaries or limits\n    corner.append(0)  # The smallest non-negative integer, boundary\n    # Generating maximum allowed value as per constraints\n    corner.append(10000)  \n    # Just below upper boundary\n    corner.append(9999)  \n    # Edge cases with odd and even numbers just above 1\n    corner += [2, 3]\n\n    # Time test cases: Large inputs that are meant to challenge the execution time.\n    # Testing near the upper limit\n    for i in range(10000, 9975, -1):\n        time.append(i)\n\n    # Space test cases: Inputs designed to test memory usage and constraints.\n    # Large values focusing on memory\n    for i in range(5000, 5025):\n        space.append(i)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/131": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for i in range(10):  # Simple cases, typically small numbers\n        base.append(random.randint(1, 100))\n    \n    # Corner cases\n    corner.append(1)  # Smallest possible odd number\n    corner.append(2)  # Smallest possible even number\n    corner.extend([10**i + 1 for i in range(1, 10)])  # Power of ten plus one (mostly odd digits)\n    corner.extend([10**i + 2 for i in range(1, 10)])  # Power of ten plus two (even digit added)\n\n    # Time complexity cases\n    for i in range(25):  # Large numbers, challenge the efficiency of the function\n        time.append(random.randint(1, 10**18))\n    \n    # Space complexity cases\n    for i in range(25):  # Wide range of numbers with more odd digits\n        # Creating numbers where more odd digits are involved\n        number = int(''.join(str(random.choice([1, 3, 5, 7, 9])) for _ in range(18)))\n        space.append(number)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/132": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Simple cases with clear nested and non-nested brackets\n    base.append(\"[]\")                      # Not nested\n    base.append(\"[[]]\")                    # Nested\n    base.append(\"[[][]]\")                  # Nested\n    base.append(\"[][][]\")                  # Not nested\n    base.append(\"[[[]]]\")                  # Nested\n\n    # Expanding base cases to reach 25\n    while len(base) < 25:\n        rand_len = random.randint(1, 10)\n        base_case = ''.join(random.choice('[]') for _ in range(rand_len))\n        base.append(base_case)\n\n    # Corner Cases: Edge scenarios\n    corner.append(\"[]\" * 50)               # Not nested, maximum length\n    corner.append(\"[[]\" * 50 + \"]\" * 50)   # Nested, maximum length\n    corner.append(\"[\" * 50 + \"]\" * 50)     # Perfectly matched large input\n    corner.append(\"]\" * 50 + \"[\" * 50)     # Unmatched large input\n    corner.append(\"[[[\" * 33 + \"]]]\" * 33) # Nested deep\n\n    # Expanding corner cases to reach 25\n    while len(corner) < 25:\n        structure = \"[[]\" * random.randint(1, 10) + \"[]\" * random.randint(1, 10)\n        corner.append(structure)\n\n    # Time Complexity Cases: Large inputs to test performance\n    for _ in range(25):\n        length = random.randint(90, 100)\n        nested_mix = \"\".join(random.choice(\"[[]]\") for _ in range(length))\n        time.append(nested_mix)\n\n    # Space Complexity Cases: Large yet structured inputs to test memory usage\n    for _ in range(25):\n        blocks = random.randint(10, 15)\n        space_case = (\"[[]\" * blocks + \"[]\" * blocks + \"]\" * blocks)\n        space.append(space_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/133": [
        "# Import statements\nfrom typing import List, Tuple, Union\nimport random\nimport math\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[Union[int, float]]], \n                                  List[List[Union[int, float]]], \n                                  List[List[Union[int, float]]], \n                                  List[List[Union[int, float]]]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for _ in range(25):\n        # Generate list with 3 to 10 positive and negative integers or floats\n        case = [random.uniform(-100, 100) for _ in range(random.randint(3, 10))]\n        base.append(case)\n\n    # Corner Cases\n    for _ in range(25):\n        # Empty list (it should be ignored by constraint, but we test if guarded properly)\n        if _ == 0:\n            corner.append([])\n        # Large numbers very close to integers\n        elif _ == 1:\n            corner.append([999999.9, 1000000.1, -999999.9])\n        # Very small numbers and their negations\n        elif _ == 2:\n            corner.append([0.0001, -0.0001, 0.9999])\n        # List with zeros\n        elif _ == 3:\n            corner.append([0, 0.0, -0.0])\n        else:\n            # Other random corner cases with varied types\n            corner.append([random.uniform(-1e-9, 1e-9) for _ in range(5)])\n\n    # Time Complexity Cases\n    increment = 10000 // 25  # To generate 10000 numbers total, in chunks\n    for i in range(25):\n        # Generating large test cases to test time complexity\n        size = increment * (i + 1)\n        case = [random.uniform(-1000, 1000) for _ in range(size)]\n        time.append(case)\n\n    # Space Complexity Cases\n    for i in range(25):\n        # Generating lists with large size (within a reasonable limit for Python recursive depth)\n        case = [random.uniform(-500, 500) for _ in range(100 * (i + 1))]\n        space.append(case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/134": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append(\"apple pie\")\n    base.append(\"apple pi e\")\n    base.append(\"apple pi e \")\n    base.append(\"\")\n    base.append(\"a\")\n\n    # Corner cases\n    corner.append(\" \")\n    corner.append(\"1\")\n    corner.append(\"!@#$%^&*()\")\n    corner.append(\"word \")\n    corner.append(\"  word\")\n    corner.append(\"wor d \")\n\n    # Time complexity cases\n    for _ in range(25):\n        text_length = random.randint(1, 1000)\n        test_text = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation + ' ', k=text_length))\n        time.append(test_text)\n\n    # Space complexity cases\n    for _ in range(25):\n        text_length = random.randint(1001, 5000)\n        inner_text = ''.join(random.choices(string.ascii_letters + string.digits + string.punctuation, k=text_length-2))\n        if random.choice([True, False]):\n            # Ensures the last character is alphabetical followed by space\n            space.append(inner_text + random.choice(string.ascii_letters) + ' ')\n        else:\n            # No space after the last character\n            space.append(inner_text + random.choice(string.ascii_letters))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/135": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        # Create arrays of random lengths (at least 2 to ensure we can have a valid non-increasing element)\n        length = random.randint(2, 10)\n        arr = sorted(random.sample(range(1, 100), length), reverse=random.choice([True, False]))\n        base.append(arr)\n\n    # Corner cases\n    corner.append([1])  # Single element case\n    corner.append([])   # Empty list case (though it should be filtered out by constraints in reality)\n    for _ in range(23):\n        arr = sorted(random.sample(range(1, 100), 2), reverse=random.choice([True, False]))\n        if random.random() > 0.5:\n            # Make sure to create a strictly increasing order to produce a -1 output\n            arr.sort()\n        corner.append(arr)\n\n    # Time complexity cases\n    for _ in range(25):\n        length = random.randint(1000, 2000)\n        arr = random.sample(range(1, 10000), length)\n        time.append(arr)\n\n    # Space complexity cases\n    for _ in range(25):\n        # Generate large arrays with larger range of integers\n        length = random.randint(800, 1200)\n        arr = random.sample(range(-100000, 100000), length)\n        space.append(arr)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/136": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases - Simple and typical inputs\n    for _ in range(25):\n        n = random.randint(1, 10)  # Number of elements in the list\n        lst = random.choices(range(-100, 101), k=n)\n        base.append(lst)\n    \n    # Corner cases - Special cases, boundary values or rare situations\n    corner.append([])  # Empty list\n    corner.append([0] * 10)  # List of zeroes\n    corner.append([random.randint(1, 100) for _ in range(20)])  # List of positive numbers only\n    corner.append([-random.randint(1, 100) for _ in range(20)])  # List of negative numbers only\n    for _ in range(21):\n        lst = [0] * random.randint(1, 5) + [random.randint(-100, 0) for _ in range(random.randint(5, 10))]\n        corner.append(lst)\n    \n    # Time complexity cases - Large inputs to test the efficiency\n    for _ in range(25):\n        n = random.randint(50000, 100000)\n        lst = random.choices(range(-1000000, 1000000), k=n)\n        time.append(lst)\n    \n    # Space complexity cases - Inputs designed to test memory usage\n    for _ in range(25):\n        n = random.randint(1000, 5000)\n        lst = random.choices(range(-1000, 1000), k=n)\n        space.append(lst)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/137": [
        "# Import statements\nfrom typing import Tuple, Union, Any, List, Generator\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Case generation\n    for _ in range(25):\n        x = random.randint(-100, 100)\n        y = random.uniform(-100.0, 100.0)\n        base.append((x, y))\n    \n    # Corner Case generation\n    for _ in range(25):\n        x = random.choice([float('inf'), float('-inf')])\n        y_str = f\"{random.randint(-100, 100)},{random.randint(1, 99)}\"\n        corner.append((x, y_str))\n        \n    # Time complexity case generation\n    for _ in range(25):\n        x = random.randint(-1000000, 1000000)\n        y = random.uniform(-1000000.0, 1000000.0)\n        time.append((x, y))\n        \n    # Space complexity case generation\n    for _ in range(25):\n        x = f\"{random.randint(-10000, 10000)}.{random.randint(1, 99)}\"\n        y = f\"{random.randint(-10000, 10000)},{random.randint(1, 99)}\"\n        space.append((x, y))\n        \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/138": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for n in [8, 10, 12, 16]:  # Basic valid cases with minimum sums of even numbers\n        base.append(n)\n    \n    # Additional base cases\n    for i in range(17, 25):    # Increment cases slightly above the minimum valid even sum\n        base.append(i * 2) \n\n    # Corner cases\n    corner.extend([0, 2, 4, 6, 7])  # Even numbers less than 8 and an odd number close to 8\n\n    # Time complexity cases\n    for i in range(25):\n        time.append(random.randint(8, 10000) * 2)  # Large even numbers to test performance under higher loads\n    \n    # Space complexity cases\n    for i in range(25):\n        if i % 2 == 0:\n            space.append(random.randint(8, 1000) * 2)  # Even numbers within a moderate range\n        else:\n            space.append(i * 2 + 8)  # Sequential even numbers starting from the smallest sum\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/139": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases (Typical cases near expected operational parameters)\n    for i in range(1, 26):  # range from 1 to 25\n        base.append(i)\n\n    # Corner cases (Cases that are unique or unusual, such as very small or large numbers)\n    corner.append(1)  # Check the smallest input bigger than zero\n    corner.append(2)  # Check the next smallest input\n    for i in range(23):\n        corner.append(100 + i)  # Large numbers starting from 100 to 122\n\n    # Time Complexity cases (Designed to stress-test the efficiency of the solution)\n    for i in range(25, 50):  \n        time.append(i)  # Mid-range numbers to stress factorial calculations\n\n    # Space Complexity cases (Designed to potentially exploit any space inefficiency)\n    for i in range(100, 125):  # Large numbers to check space usage due to large outputs\n        space.append(i)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/14": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases: Typical cases with different string patterns\n    for _ in range(25):\n        length = random.randint(1, 10)  # Reasonable length to analyze basic behavior\n        random_string = ''.join(random.choices(string.ascii_letters, k=length))\n        base.append(random_string)\n    \n    # Corner cases: Focus on very specific or unusual inputs\n    corner.append(\"\")  # Edge case with empty string though it should be non-empty as per constraints\n    corner.append(\"a\")  # Smallest typical single character string\n    corner.append(\"@\" * 10)  # Special characters string\n    for _ in range(22):\n        length = random.randint(1, 10)\n        random_string = ''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase + string.digits, k=length))\n        corner.append(random_string.swapcase())  # Case swapping to add variation\n\n    # Time complexity cases: Larger inputs to test efficiency\n    for _ in range(25):\n        length = random.randint(900, 1000)  # Nearing the upper limit\n        random_string = ''.join(random.choices(string.ascii_letters, k=length))\n        time.append(random_string)\n    \n    # Space complexity cases: Strings that might be interesting in terms of memory usage\n    for _ in range(25):\n        length = random.randint(500, 1000)\n        pattern = random.choice(string.ascii_letters)  # Repeated character to emphasize same character handling\n        random_string = pattern * length\n        space.append(random_string)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/140": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        # A simple string with one space\n        base_word = ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(1, 10)))\n        base.append(base_word + \" \" + base_word)\n\n    # Corner cases\n    corner.append(\"A  -_-B\")\n    corner.append(\"A --B\")\n    corner.append(\"A __-B\")\n    corner.append(\"A --B- -C\")\n    corner.append(\"A  _-B-_  C\")\n    for _ in range(25):\n        # A string starting and ending with spaces\n        corner_word = ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(1, 8)))\n        corner.append(\" \" + corner_word + \" \")\n\n        # A string with exactly two consecutive spaces\n        corner.append(corner_word + \"  \" + corner_word)\n\n        # A string with more than two spaces, including tabs and newlines\n        corner.append(corner_word + \"   \" + corner_word)\n\n    # Time complexity cases\n    for _ in range(25):\n        # Very long strings with very few spaces\n        time_word = ''.join(random.choices(string.ascii_letters + string.digits, k=9995))\n        # insert random spaces\n        for _ in range(50):\n            idx = random.randint(0, 9995)\n            time_word = time_word[:idx] + \" \" * random.randint(1, 10) + time_word[idx:]\n        time.append(time_word + \" \" + time_word)\n\n        # Very long strings with maximum number of spaces\n        mixed_chars = string.ascii_letters + \"     \"\n        time.append(''.join(random.choices(mixed_chars, k=10000)))\n\n    # Space complexity cases\n    for _ in range(25):\n        # Large strings with random placement of double spaces\n        space_string = ''.join(random.choices(string.ascii_letters + \"  \", k=10000))\n        space.append(space_string)\n\n        # Large strings with multiple non-space characters interleaved with spaces\n        mixed_space_chars = string.ascii_letters + \" \"\n        space.append(''.join(random.choices(mixed_space_chars, k=10000)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/141": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Helper function to generate random strings\n    def random_string(length: int, with_digits: bool, exact_dots: int) -> str:\n        valid_chars = string.ascii_letters + ('.' if exact_dots > 0 else '')\n        if with_digits:\n            valid_chars += string.digits\n        result = ''\n        dot_count = 0\n        for _ in range(length):\n            char = random.choice(valid_chars)\n            if char == '.':\n                if dot_count < exact_dots:\n                    dot_count += 1\n                else:\n                    continue\n            result += char\n        return result\n\n    # Base cases - Valid file names\n    for _ in range(25):\n        prefix = random.choice(string.ascii_letters) + random_string(random.randint(0, 5), True, 0)\n        suffix = random.choice([\"txt\", \"exe\", \"dll\"])\n        base.append(prefix + '.' + suffix)\n\n    # Corner cases - Edge scenarios\n    # Exactly 3 digits, borderline valid prefixes and suffixes\n    corner.append('a123.txt')  # Exactly at the limit of digits\n    corner.append('b234.exe')  # Exactly at the limit of digits\n    corner.append('.a123.dll')  # Starts with a dot, invalid\n    corner.append('d456.txt.')  # Ends with a dot, invalid\n    for _ in range(21):  # Fill remaining cases\n        digits = random.randint(0, 3)\n        prefix = random_string(random.randint(1, 5), True, 0)\n        suffix = random.choice([\"txt\", \"exe\", \"dll\"])\n        corner.append(prefix + str(digits) + '.' + suffix)\n\n    # Time complexity cases - Larger inputs to test processing capability\n    for _ in range(25):\n        prefix = random.choice(string.ascii_letters) + random_string(50, True, 0)  # Long prefix\n        suffix = random.choice([\"txt\", \"exe\", \"dll\"])\n        time.append(prefix + '.' + suffix)\n\n    # Space complexity cases - Generate sets of data that could test space usage\n    for _ in range(25):\n        prefix = random.choice(string.ascii_letters) + random_string(random.randint(10, 20), True, 0)\n        suffix = random.choice([\"txt\", \"exe\", \"dll\"])\n        space.append(prefix + '.' + suffix)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/142": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    base.append([i for i in range(10)])  # List from 0 to 9\n    base.append([0] * 10)                # List of zero integers\n    base.append([-1] * 10)               # List of negative integers\n    \n    for _ in range(22):\n        base.append([random.randint(-100, 100) for _ in range(random.randint(1, 10))])\n\n    # Corner Test Cases\n    corner.append([])                    # Empty list\n    corner.append([3 ** 20])             # Very large number\n    corner.append([-3 ** 20])            # Very large negative number\n    \n    for _ in range(22):\n        corner.append([random.randint(-10 ** 9, 10 ** 9) for _ in range(1)])  # Lists with a single very large or small number\n\n    # Time Complexity Test Cases\n    for _ in range(25):\n        time.append([random.randint(-1000, 1000) for _ in range(10 ** 3)])   # Lists with 1,000 elements\n\n    # Space Complexity Test Cases\n    space.append([0] * (10 ** 6))        # List of 1 million zero integers\n    space.append([1, 2] * (5 * 10 ** 5)) # List of 1 million integers alternating between 1 and 2\n    \n    for _ in range(23):\n        space.append([random.randint(-10, 10) for _ in range(10 ** 6)])      # Maximum size list with small range numbers\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/143": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case Generation\n    base = [\n        \"a quick brown fox\",  # normal case\n        \"jump over the lazy dog\",  # all words have lengths non-prime\n        \"we love prime numbers in nature\",  # mix of prime and non-prime word lengths\n        \"is\",  # single word, prime length\n        \"a\"  # single word, non-prime length\n    ]\n\n    # Corner Case Generation\n    corner = [\n        \"\",  # empty string\n        \"a\" * 100,  # max length sentence with non-prime word length\n        \"a \" + \"a\" * 97,  # edge case with one very long word and a short one\n        \"i\" * 23,  # prime length\n        \"a b c i o u\"  # mixing prime and non-prime small words\n    ]\n\n    # Time Complexity Cases - Testing performance by maxing constraints\n    for i in range(25):\n        sentence = \"a\" * (100 - i) + \" \" + \"i\" * i\n        time.append(sentence)\n\n    # Space Complexity Cases - Testing input with large continuous sequences or special structure\n    for i in range(25):\n        sentence = \"b\" * 2 + \" \" + \"c\" * 3 + \" \" + \"a\" * (i + 1)\n        space.append(sentence)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/144": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base cases\n    for i in range(25):\n        numerator1 = random.randint(1, 10)\n        denominator1 = random.randint(1, 10)\n        numerator2 = random.randint(1, 10)\n        denominator2 = random.randint(1, 10)\n        base.append((f\"{numerator1}/{denominator1}\", f\"{numerator2}/{denominator2}\"))\n\n    # Generating corner cases\n    corner.append((\"1/1\", \"1/1\"))  # Simplest case of true\n    corner.append((\"1/1\", \"0/1\"))  # Edge case, although denominator will never be zero as per constraints\n    corner.append((\"999999/999999\", \"999999/999999\"))  # Edge case for large numbers, should return True\n    for i in range(22):\n        n = random.randint(1, 1000)\n        corner.append((f\"{n}/{n}\", f\"{n}/{n}\"))  # Large numbers, equivalent fractions\n\n    # Generating time complexity cases\n    for i in range(25):\n        large_number1 = random.randint(100000, 999999)\n        large_number2 = random.randint(100000, 999999)\n        time.append((f\"{large_number1}/{large_number2}\", f\"{large_number2}/{large_number1}\"))\n\n    # Generating space complexity cases\n    for i in range(25):\n        # Fractions that when multiplied lead to a very small number\n        small_number1 = random.randint(1, 10)\n        large_number1 = random.randint(1000000, 10000000)\n        small_number2 = random.randint(1, 10)\n        large_number2 = random.randint(1000000, 10000000)\n        space.append((f\"{small_number1}/{large_number1}\", f\"{small_number2}/{large_number2}\"))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/145": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case Test\n    # General operational test cases with normal input sizes\n    for _ in range(25):\n        numbers = [random.randint(-100, 100) for _ in range(random.randint(1, 10))]\n        base.append(numbers)\n\n    # Corner Case Test\n    # Extreme edges of the functionality\n    # Empty list \n    corner.append([])\n    # Single element list\n    corner.extend([[random.randint(-1000, 1000)] for _ in range(10)])\n    # List with all same elements\n    corner.append([5] * 10)\n    # List with maximum range of integers\n    corner.extend([[random.randint(-2**20, 2**20) for _ in range(10)] for _ in range(8)])\n\n    # Time Complexity Case Test\n    # Large input sizes to test the function's performance\n    for _ in range(25):\n        numbers = [random.randint(-1000, 1000) for _ in range(1000)]\n        time.append(numbers)\n\n    # Space Complexity Case Test\n    # Large single values to check memory usage under extreme cases\n    for _ in range(25):\n        numbers = [random.randint(-10**9, 10**9) for _ in range(100)]\n        space.append(numbers)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/146": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for _ in range(25):\n        nums = [random.choice(range(-100, 100)) for _ in range(random.randint(5,10))]\n        base.append(nums)\n\n    # Corner Cases\n    for _ in range(25):\n        # All numbers less than 10\n        nums1 = [random.choice(range(-100, 10)) for _ in range(random.randint(5,10))]\n        # All numbers just greater than 10\n        nums2 = [random.choice([11, 13, 15, 17, 19]) for _ in range(random.randint(5, 10))]\n        # Mixed edge cases with large and small values\n        nums3 = [random.choice([-2**31, 2**31-1, 0, 12, 13]) for _ in range(random.randint(5, 10))]\n        # List with negative odd values\n        nums4 = [-random.choice([11, 13, 15, 17, 19]) for _ in range(random.randint(5, 10))]\n        corner.extend([nums1, nums2, nums3, nums4])\n\n    # Time Complexity Cases\n    for _ in range(25):\n        nums = [random.choice(range(-100, 100)) for _ in range(1000)]\n        time.append(nums)\n\n    # Space Complexity Cases\n    for _ in range(25):\n        nums = [random.choice([13, 31, 15, 51, 19, 91]) if i % 5 == 0 else random.randint(1, 100) for i in range(1000)]\n        space.append(nums)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/147": [
        "# Import statements\nfrom typing import List, Any, Tuple\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Regular sizes\n    for i in range(1, 26):\n        base.append(i)\n\n    # Corner Cases: Small n values close to limit and maximum meaningful values\n    corner.append(1)  # Minimum value of n\n    corner.append(2)  # Just over the minimum\n    corner.append(3)  # First potential triple\n    corner.extend([99, 100, 101, 1000])  # Large n values to test edge behaviors\n\n    # Time Complexity Cases: Large values to stress test computation time\n    for i in range(100000, 100000 + 25):\n        time.append(i)\n\n    # Space Complexity Cases: Large values to test memory usage\n    for i in range(1000000, 1000000 + 25):\n        space.append(i)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/148": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]]]:\n    base, corner, time, space = [], [], [], []\n    planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\n    # Base test cases\n    for _ in range(25):\n        planet1, planet2 = random.sample(planets, 2)\n        base.append((planet1, planet2))\n\n    # Corner test cases\n    for _ in range(25):\n        # Testing with smallest and largest indices\n        planet1 = planets[0]  # Mercury\n        planet2 = planets[-1]  # Neptune\n        corner.append((planet1, planet2))\n        # Reversed order\n        corner.append((planet2, planet1))\n\n    # Time complexity test cases\n    # Using the same pair multiple times to simulate higher processing\n    planet_pair = random.sample(planets, 2)\n    for _ in range(50):\n        time.append(tuple(planet_pair))\n        \n    # Space complexity test cases\n    # Using the same planet as planet1 and varying planet2\n    fixed_planet = random.choice(planets)\n    for planet in planets:\n        if planet != fixed_planet:\n            space.append((fixed_planet, planet))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/149": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append([\"apple\", \"banana\", \"cherry\"])  # All have even lengths\n    base.append([])  # Empty list\n    base.append([\"dog\", \"cat\", \"bird\", \"fish\"])  # Mixed even and odd lengths\n    base.append([\"a\" * i for i in range(2, 50, 2)])  # Increasing even lengths\n    while len(base) < 25:\n        base.append([random.choice(string.ascii_lowercase) * random.randint(2, 10) for _ in range(10)])\n\n    # Corner cases\n    corner.append([\"aa\", \"a\" * 99, \"aaa\" * 33])  # Long strings with odd and even lengths\n    corner.append([\"ba\", \"ab\"])  # Words with same lengths\n    corner.append([\"a\" * 2 for _ in range(100)])  # Duplicate even length strings\n    corner.append([\"\"] * 20)  # List full of empty strings (even length)\n    while len(corner) < 25:\n        n = random.choice([0, 1])\n        corner.append([random.choice(string.ascii_lowercase) * (2 + n) for _ in range(10)])\n\n    # Time complexity cases\n    for _ in range(25):\n        time.append([random.choice(string.ascii_lowercase) * random.randint(2, 10) for _ in range(1000)])\n\n    # Space complexity cases\n    for _ in range(25):\n        space.append([\"a\" * 2000 for _ in range(100)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/15": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases - standard sequential values from 0 to 24\n    base = [i for i in range(25)]\n\n    # Corner test cases - edge values\n    corner = [0]  # n = 0, the smallest non-negative integer\n    corner.extend([2**i - 1 for i in range(3, 8)])  # Values just under powers of 2, up to 127\n\n    # Time complexity test cases - very large values to test performance\n    time = [10**i for i in range(2, 7)]  # 100, 1000, 10000, 100000, 1000000\n\n    # Space complexity test cases - moderately large values to observe memory usage\n    space = [i * 100 for i in range(25, 50)]  # from 2500 to 4900, increasing by 100\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/150": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Simple and expected common cases\n    base.append((2, 5, 3))  # 2 is a prime number\n    base.append((4, 7, 10)) # 4 is not a prime number\n    for i in range(3, 28):\n        base.append((i, i, i + 1)) # Alternating between prime and not prime numbers\n\n    # Corner cases: Include limits or extreme cases, especially with small numbers\n    corner.append((1, 0, 0))  # smallest non-prime due to n <= 0 condition\n    corner.append((2, -1, 1)) # smallest prime number, with negative x\n    corner.append((3, 1, -1)) # testing consecutive small prime with negative y\n    corner.append((997, 1000, -1000)) # larger prime near 1000\n\n    # Time complexity cases: Designed to test the function's performance under large inputs\n    for i in range(1000000, 1000025):\n        time.append((i, 1, 2))  # Use large candidate numbers for primality checking\n\n    # Space complexity cases: Designed to handle large values of x and y\n    for i in range(1, 26):\n        space.append((5, 10**6 * i, 10**6 * i + 1)) # Prime number with increasingly large x and y\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/151": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    for _ in range(25):\n        base.append([random.randint(1, 10) for _ in range(random.randint(1, 5))])\n    \n    # Corner Test Cases\n    corner.append([])  # Empty list\n    corner.append([0]*5)  # List of zeros\n    corner.append([1]*5)  # List of ones\n    for _ in range(22):\n        # All negative or zero\n        corner.append([random.randint(-10, 0) for _ in range(random.randint(1, 5))])\n    \n    # Time Complexity Test Cases (Long Lists)\n    for _ in range(25):\n        time.append([random.randint(-100, 100) for _ in range(1000)])\n    \n    # Space Complexity Test Cases (Test cases with high and low values)\n    for _ in range(25):\n        # Alternate high positive and high negative for a realistic yet challenging input\n        space.append([random.choice([1000, -1000]) for _ in range(random.randint(10, 20))])\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/152": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases: expected normal usage\n    for i in range(25):\n        length = random.randint(1, 10)  # modest length\n        game = [random.randint(0, 10) for _ in range(length)]\n        guess = [random.randint(0, 10) for _ in range(length)]\n        base.append((game, guess))\n    \n    # Corner cases: extreme minimal and maximal values\n    for i in range(25):\n        if i < 13:  # very small arrays\n            game = [random.randint(0, 10) for _ in range(1)]\n            guess = [random.randint(0, 10) for _ in range(1)]\n        else:  # maximum possible value cases\n            game = [random.randint(1000, 2000) for _ in range(5)]\n            guess = [random.randint(1000, 2000) for _ in range(5)]\n        corner.append((game, guess))\n    \n    # Time complexity cases: largest valid input sizes\n    for i in range(25):\n        length = 1000  # large length\n        game = [random.randint(0, 100) for _ in range(length)]\n        guess = [random.randint(0, 100) for _ in range(length)]\n        time.append((game, guess))\n    \n    # Space complexity cases: moderate size but repeated many times (memory constraints)\n    for i in range(25):\n        length = 50  # moderate large size to test space complexity\n        game = [random.randint(-100, 100) for _ in range(length)]\n        guess = [random.randint(-100, 100) for _ in range(length)]\n        space.append((game, guess))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/153": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case: Simple and standard scenarios\n    for _ in range(25):\n        class_name = \"Base\" + str(random.randint(1, 100))\n        extensions = ['Ext' + ''.join(random.choices(string.ascii_letters, k=random.randint(1, 10))) for _ in range(5)]\n        base.append((class_name, extensions))\n\n    # Corner Case: Includes edge cases with minimum or maximum values\n    for _ in range(25):\n        class_name = \"Corner\" + str(random.randint(1, 100))\n        # Create an edge case with very high or very low strength\n        extensions = ['AAA' * 10, 'aaa' * 10] + ['Ext' + ''.join(random.choices(string.ascii_letters, k=5)) for _ in range(3)]\n        corner.append((class_name, extensions))\n\n    # Time Complexity: Test cases to test the efficiency with large inputs\n    for _ in range(25):\n        class_name = \"Time\" + str(random.randint(1, 100))\n        # Large number of extensions\n        extensions = ['Ext' + ''.join(random.choices(string.ascii_letters, k=random.randint(1, 20))) for _ in range(200)]\n        time.append((class_name, extensions))\n\n    # Space Complexity: Test cases to check the behavior with large individual input size\n    for _ in range(25):\n        class_name = \"Space\" + str(random.randint(1, 100))\n        # Extensions with very long names\n        extensions = ['Ext' + ''.join(random.choices(string.ascii_letters + string.digits, k=1000)) for _ in range(10)]\n        space.append((class_name, extensions))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/154": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    for _ in range(25):\n        a_length = random.randint(10, 50)\n        b_length = random.randint(5, a_length)\n        a = ''.join(random.choices(string.ascii_lowercase, k=a_length))\n        start_idx = random.randint(0, a_length - b_length)\n        b = a[start_idx:start_idx + b_length]\n        base.append((a, b))\n    \n    # Corner Test Cases\n    corner.append((\"a\" * 1000, \"a\"))  # Both strings identical and at limit\n    corner.append((\"a\" * 1000, \"b\"))  # Both strings different character but one at limit\n    corner.append((\"\", \"\"))  # Both strings empty\n    corner.append((\"abcd\", \"dcba\"))  # No possible rotation present\n    for _ in range(21):\n        a_length = random.randint(15, 20)\n        b_length = random.randint(1, 5)\n        a = ''.join(random.choices(string.ascii_lowercase, k=a_length))\n        b = ''.join(random.choices(string.ascii_uppercase, k=b_length))  # Ensure no match\n        corner.append((a, b))\n\n    # Time Complexity Related Test Cases\n    for _ in range(25):\n        a_length = random.randint(800, 1000)\n        b_length = random.randint(400, 800)\n        a = ''.join(random.choices(string.ascii_lowercase, k=a_length))\n        b = a[random.randint(0, a_length - b_length) : random.randint(0, a_length - b_length) + b_length] \n        time.append((a, b))\n\n    # Space Complexity Related Test Cases\n    for _ in range(25):\n        a_length = random.randint(900, 1000)\n        b_length = random.randint(450, 500)\n        a = ''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase, k=a_length))\n        b = ''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase, k=b_length))\n        space.append((a, b))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/155": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    # Initialize empty lists for four types of test cases\n    base, corner, time, space = [], [], [], []\n\n    # Generating Base Cases\n    # Simple base cases with different lengths of digits\n    base.append(0)\n    base.append(1)\n    base.append(-1)\n    base.append(10)\n    base.append(-10)\n    base.append(101)\n    base.append(-101)\n\n    # Generating Corner Cases\n    # Minimum and Maximum 32-bit integer values\n    corner.append(-2**31)\n    corner.append(2**31 - 1)\n    corner.append(100000000)     # Exactly limiting boundary typically messes up calculations\n    corner.append(-100000000)    # Same as above but negative\n    corner.append(111111111)     # All odd numbers\n    corner.append(222222222)     # All even numbers\n\n    # Generating Time Complexity Cases\n    # Large numbers test the efficiency\n    for _ in range(25):\n        time.append(random.randint(-2**31, 2**31 - 1))\n\n    # Generating Space Complexity Cases\n    # Max length of digits still within range\n    max_length_positive = '9' * 10\n    max_length_negative = '-' + max_length_positive\n    space.append(int(max_length_positive))\n    space.append(int(max_length_negative))\n    for _ in range(23):\n        number = random.randint(-2**31, 2**31 - 1)\n        space.append(number)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/156": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Regular inputs across the range\n    base.extend([1, 5, 10, 50, 100, 500, 1000])\n\n    # Corner cases: Edge of boundaries and special transitions\n    corner.extend([1, 1000, 999, 998, 2, 3, 4, 6, 9, 89, 90, 399, 400, 500])\n\n    # Time complexity cases: Designed to test the upper limit of the function\n    for n in range(950, 1001):  # High values close to the upper boundary\n        time.append(n)\n\n    # Space complexity cases: Ensure the function handles the full range of numbers\n    for n in range(1, 1001, 13):  # Numbers spread across the entire range\n        space.append(n)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/157": [
        "# Import statements\nimport random\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - typical right-angle triangles\n    base_triples = [(3, 4, 5), (5, 12, 13), (8, 15, 17), (7, 24, 25)]\n    for _ in range(25):\n        a, b, c = random.choice(base_triples)\n        base.append((a, b, c))\n\n    # Corner cases - include edge cases and minimal values\n    corner.append((1, 1, 1))  # all sides equal, not a right-angle triangle\n    corner.append((1000, 1000, 1414))  # large numbers, not a right-angle triangle but close\n    for _ in range(23):\n        a, b = random.randint(1, 10), random.randint(1, 10)\n        c = a + b - 1 \n        corner.append((a, b, c))  # `c` is just less than a+b to ensure it doesn't form a triangle (invalid)\n\n    # Time cases - large inputs to test efficiency\n    for _ in range(25):\n        a, b = random.randint(1, 10000), random.randint(1, 10000)\n        c = int((a**2 + b**2)**0.5)  # making sure it's a right-angle triangle\n        if random.choice([True, False]):  # introduce some wrong ones\n            c += random.randint(-10, 10)\n        time.append((a, b, c))\n\n    # Space cases - extreme and boundary values that are valid\n    space.append((2**31 - 1, 2**31 - 1, 2**31 - 1))  # large values\n    space.append((1, 1, 2**0.5))  # minimal values\n    for _ in range(23):\n        a, b = random.randint(100000, 1000000), random.randint(100000, 1000000)\n        c = int((a**2 + b**2)**0.5)\n        space.append((a, b, c))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/158": [
        "# Import statements\nfrom typing import List, Tuple\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[str]], List[List[str]], List[List[str]], List[List[str]]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        num_words = random.randint(1, 10)\n        words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10))) for _ in range(num_words)]\n        base.append(words)\n    \n    # Corner Cases\n    # Case 1: All words same\n    corner.append([\"aaaa\"] * 100)\n    # Case 2: Some empty items, which isn't valid according to constraints, so we filter them\n    corner.append([\"\" if i % 10 == 0 else ''.join(random.choices(string.ascii_lowercase, k=5)) for i in range(100)])\n    # Case 3: Long strings\n    corner.append([''.join(random.choices(string.ascii_lowercase, k=1000)) for _ in range(10)])\n    # Case 4: Strings with max set of unique characters\n    corner.append([''.join(set(string.ascii_lowercase)) for _ in range(25)])\n    \n    # Time Complexity Cases (Designed to force the function to deal with a lot of data)\n    for _ in range(25):\n        num_words = 1000  # Large number of words to test time complexity\n        words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10))) for _ in range(num_words)]\n        time.append(words)\n    \n    # Space Complexity Cases (Designed to force the function to deal with large input sizes)\n    for _ in range(25):\n        num_words = random.randint(50, 100)\n        words = [''.join(random.choices(string.ascii_lowercase, k=random.randint(50, 200))) for _ in range(num_words)]\n        space.append(words)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/159": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base case test cases\n    for i in range(25):\n        number = i\n        need = i + 1\n        remaining = i + 2\n        base.append((number, need, remaining))\n\n    # Generating corner case test cases\n    for i in range(25):\n        if i % 4 == 0:\n            # Case when need is much larger than remaining\n            number = i\n            need = 1000\n            remaining = i\n        elif i % 4 == 1:\n            # Case when remaining is 0 but need is positive\n            number = i\n            need = i + 10\n            remaining = 0\n        elif i % 4 == 2:\n            # Case when number, need, and remaining are the same\n            number = i\n            need = i\n            remaining = i\n        else:\n            # Case when number is 0\n            number = 0\n            need = i + 5\n            remaining = i + 10\n        corner.append((number, need, remaining))\n\n    # Generating time complexity case test cases (higher volume)\n    for i in range(25):\n        number = 500 + i\n        need = 500 + (i * 2)\n        remaining = 1000 - i\n        time.append((number, need, remaining))\n\n    # Generating space complexity case test cases (varying sizes)\n    for i in range(25):\n        number = i * 10\n        need = i * 20\n        remaining = 1000 - (i * 30)\n        space.append((number, need, remaining))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/16": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases: simple, straightforward scenarios\n    base.append('abcdef')\n    base.append('AllLowerCase')\n    base.append('ALLUPPERCASE')\n    base.append('MixedCase')\n    base.append('RepeatedCharacters')\n    for _ in range(20):\n        base.append(''.join(random.choice(string.ascii_letters) for _ in range(6)))  # Random 6 char strings\n\n    # Corner test cases: extreme conditions within normal operation\n    corner.append('a')  # Minimum length\n    corner.append('AaAa')  # Same letter, different cases\n    longest_distinct = string.ascii_lowercase[:10]  # first 10 lowercase letters\n    corner.append(longest_distinct * 10)  # Repeating same set of 10 letters\n    for _ in range(21):\n        length = random.randint(1, 5)\n        corner.append(''.join(random.choice(string.ascii_letters) for _ in range(length)))  # Short strings\n\n    # Time complexity focused test cases: maximized input sizes\n    for _ in range(25):\n        time.append(''.join(random.choice(string.ascii_letters) for _ in range(1000)))  # Large strings of 1000 chars\n\n    # Space complexity focused test cases: Designed to test memory usage\n    for _ in range(25):\n        unique_chars = ''.join(set(random.choices(string.ascii_letters, k=26)))  # Up to 26 unique characters\n        repeated = unique_chars * 38  # Repeat each character to increase the size\n        space.append(repeated)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/160": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List], List[List], List[List], List[List]]:\n    base, corner, time, space = [], [], [], []\n\n\n    def calculate(operators, operands):\n        exp = \"\"\n        for i in range(len(operators)):\n            exp += str(operands[i]) + operators[i]\n        exp += str(operands[-1])\n        return eval(exp)\n\n    # Helper function to avoid large exponents and division by zero\n    def safe_operands_operators(length: int) -> Tuple[List[str], List[int]]:\n        operators = []\n        operands = []\n        operands.append(random.randint(1, 5))  # First operand\n        exponent_count = 0\n        for _ in range(length):\n            op = random.choice(['+', '-', '*', '//', '**'])\n            while op == '**' and exponent_count >= 2:\n                op = random.choice(['+', '-', '*', '//', '**'])\n            if op == '**':\n                exponent_count += 1\n                operands.append(random.randint(0, 5))  # Limit base for exponentiation\n            elif op == '//':\n                operands.append(random.randint(1, 100))  # Avoid zero for division\n            else:\n                operands.append(random.randint(0, 100))\n            operators.append(op)\n\n        return operators, operands\n\n    # Base cases: simple, typical inputs\n    for _ in range(25):\n        op_len = random.randint(1, 5)\n        operators, operands = safe_operands_operators(op_len)\n        base.append([operators, operands])\n\n    # Corner cases: edge scenarios\n    # All addition\n    corner.append([['+'] * 49, [1] * 50])\n    # All subtraction\n    corner.append([['-'] * 49, [1] * 50])\n    # All multiplication\n    corner.append([['*'] * 49, [1] * 50])\n    # All floor division (avoiding zero)\n    corner.append([['//'] * 49, [random.randint(1, 100) for _ in range(50)]])\n    # All exponentiation (with safe bases)\n    corner.append([['**'] * 2, [random.randint(0, 5) for _ in range(3)]])\n\n    # Time cases: inputs designed to challenge execution time\n    for _ in range(25):\n        op_len = random.randint(10, 30)\n        flag = False\n        while not flag:\n            try:\n                operators, operands = safe_operands_operators(op_len)\n            except Exception:\n                continue\n            flag = True\n        time.append([operators, operands])\n\n    # Space cases: inputs designed to challenge memory usage\n    for _ in range(25):\n        op_len = random.randint(15, 50)\n        flag = False\n        while not flag:\n            try:\n                operators, operands = safe_operands_operators(op_len)\n            except Exception:\n                continue\n            flag = True\n        space.append([operators, operands])\n\n    return base, corner, time, space\n\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/161": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # reasonable length for simple base cases\n        s = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))\n        base.append(s)\n\n    # Corner cases\n    # - Case with exactly one character that is a letter\n    corner.append(\"a\")\n    # - Case with exactly one character that is not a letter\n    corner.append(\"1\")\n    # - Case with all characters being the same letter\n    corner.append(\"aaaaa\")\n    # - Case with a mix of upper and lower case letters only\n    corner.append(\"aAaAaA\")\n    # - Case with the longest allowed string of 1000 characters\n    corner.append(''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(1000)))\n\n    # Time Complexity cases: Large inputs to test efficiency\n    for _ in range(25):\n        length = 995 + random.randint(0, 5)  # close to the upper constraint limit\n        s = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))\n        time.append(s)\n\n    # Space Complexity cases: Create inputs to assess memory usage\n    for _ in range(25):\n        length = random.randint(500, 1000)  # large but varying lengths\n        s = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))\n        space.append(s)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/162": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - normal inputs\n    base.extend([\n        \"Hello world\", \n        \"python\", \n        \"123456\",\n        \"Sample text\"\n    ])\n\n    # Corner cases - edge scenarios\n    corner.append(\"\")  # Empty string\n    corner.append(\" \" * 10)  # Multiple spaces\n    corner.extend([\n        \"a\" * 1000,  # Long string of repeating character\n        \"\\nnew\\nline\\ncharacters\\n\",  # Newline characters\n        \"special!@#$%^&*(){}?<>\"  # Special characters\n    ])\n\n    # Time complexity cases - large inputs\n    for _ in range(25):\n        length = random.randint(1000, 10000)\n        random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        time.append(random_string)\n\n    # Space complexity cases - diverse inputs\n    for _ in range(25):\n        length = random.randint(1, 100)\n        types = [string.ascii_lowercase, string.ascii_uppercase, string.digits, string.punctuation]\n        random_string = ''.join(random.choices(random.choice(types), k=length))\n        space.append(random_string)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/163": [
        "# Import statements\nfrom typing import Tuple, List\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]], List[Tuple[int, int]], List[Tuple[int, int]]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Test Cases\n    for i in range(1, 26):  # Small range, ordered a <= b\n        a = i\n        b = i + 2\n        base.append((a, b))\n    \n    # Corner Test Cases\n    for i in range(26, 51):  # Edge cases like even boundaries\n        a = 2 * i\n        b = 2 * i + 2\n        corner.append((a, b))\n        corner.append((b, a))  # Reverse order\n\n    # Time Complexity Test Cases\n    for i in range(51, 76):  # Large range of numbers\n        a = 1000 * i\n        b = 1000 * i + 2\n        time.append((a, b))\n    \n    # Space Complexity Test Cases\n    for i in range(76, 101):  # Similar to time but focusing on boundaries like 10\n        a = 10 * i - 2\n        b = 10 * i + 2\n        if a % 2 == 1:  # Adjust to make sure we have even boundaries\n            a += 1\n        if b % 2 == 1:\n            b -= 1\n        space.append((a, b))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/17": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases with a simple structure\n    for i in range(25):\n        note_sequence = ' '.join(['o', 'o|', '.|'] * (i + 1))\n        base.append(note_sequence)\n\n    # Generate corner test cases with all possible minimal and maximal valid inputs\n    corner.append('o')  # Minimum valid input\n    corner.append('o|')\n    corner.append('.|')\n    corner.append('o o| .|')  # Mixed minimum notes\n    for _ in range(21):\n        long_sequence = ' '.join(['o'] * 50)  # Maximal valid input of single type\n        corner.append(long_sequence)\n        long_mixed_sequence = ' '.join(['o', 'o|', '.|'] * 50)  # Maximal mixed notes\n        space.append(long_mixed_sequence)\n\n    # Generate time complexity test cases\n    for i in range(25):\n        lengthy_note_sequence = ' '.join(['o', 'o|', '.|'] * 100)  # Very long sequence to test time limits\n        time.append(lengthy_note_sequence)\n\n    # Generate space complexity test cases\n    for i in range(25):\n        repeating_note_sequence = ' '.join(['o o| .|'] * (i + 20))  # Large input size to challenge space\n        space.append(repeating_note_sequence)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/18": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Helper function to generate a random string\n    def random_string(length):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n    \n    # Base cases\n    for _ in range(25):\n        s = random_string(random.randint(1, 20)) \n        sub = random_string(random.randint(1, len(s))) \n        base.append((s, sub))\n    \n    # Corner cases\n    corner.append((\"\", \"a\"))  # Case with empty main string\n    s = random_string(20)\n    corner.append((s, s))  # Case where substring is the same as the main string\n    corner.append((s, s + \"a\"))  # Substring longer than the main string which should be invalid\n    corner.append((\"a\" * 100, \"a\"))  # Large repetitive character string\n    \n    # Time complexity cases\n    for _ in range(25):\n        s = random_string(random.randint(80, 100))  # Large strings\n        sub = random_string(random.randint(1, 5))  # Relatively smaller substrings\n        time.append((s, sub))\n    \n    # Space complexity cases\n    for _ in range(25):\n        s = \"a\" * random.randint(100, 200)  # Large repetitive strings\n        sub = \"a\" * random.randint(1, min(5, len(s)))  # Small repetitive substrings\n        space.append((s, sub))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/19": [
        "from typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    number_words = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n\n    # Generating base test cases\n    for _ in range(25):\n        nums = random.sample(number_words, random.randint(1, 9))\n        base.append(\" \".join(nums))\n    \n    # Generating corner test cases\n    # 1. Single element test case\n    for word in number_words:\n        corner.append(word)\n        \n    # 2. Reverse sorted\n    corner.append(\" \".join(reversed(number_words)))\n    \n    # 3. Already sorted\n    corner.append(\" \".join(number_words))\n\n    # Generating time complexity test cases\n    # 100 single repeated word, stress testing the input length\n    time.append(\" \".join([random.choice(number_words) for _ in range(100)]))\n\n    # Generating space complexity test cases\n    # Very long single string\n    space.append(\" \".join(random.choices(number_words, k=1000)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/2": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for _ in range(25):\n        # Generate simple positive float numbers with 1 decimal place\n        base.append(random.uniform(1, 10))\n\n    # Corner Cases\n    for _ in range(25):\n        # Consider very small decimal parts close to zero but not zero\n        corner.append(random.uniform(0.000001, 0.0001))\n        \n        # Consider decimal parts very close to 1\n        corner.append(random.uniform(1.9999, 1.999999))\n\n        # Large numbers with small decimal parts\n        corner.append(random.uniform(1000000, 1000000.0001))\n\n    # Time Complexity Cases\n    for _ in range(25):\n        # Very large numbers to test the handling of large inputs\n        time.append(random.uniform(1e10, 1e10 + 1))\n\n    # Space Complexity Cases\n    for _ in range(25):\n        # Large numbers with more decimal places to test precision and handling\n        space.append(random.uniform(1e5, 1e5 + 0.999999))\n\n    # Ensure all lists fulfill the requested amount due to rounding\n    corner = corner[:25]\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/20": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[float]], List[List[float]], List[List[float]], List[List[float]]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases (simple scenarios with small lists)\n    for _ in range(25):\n        size = random.randint(2, 10)  # Small list size\n        numbers = [random.uniform(-100, 100) for _ in range(size)]\n        base.append(numbers)\n    \n    # Corner cases (critical edge scenarios, e.g., minimum size input, very close numbers)\n    for _ in range(25):\n        # Exactly two elements, possibly very close\n        corner.append([random.uniform(0, 1), random.uniform(0, 1)])\n    \n    # Time complexity cases (large size inputs to test the performance, especially the sort operation)\n    for _ in range(25):\n        size = random.randint(1000, 2000)  # Large list size\n        numbers = [random.uniform(-1000, 1000) for _ in range(size)]\n        time.append(numbers)\n    \n    # Space complexity cases (focus on small lists but with extremely high or low values)\n    for _ in range(25):\n        size = random.randint(2, 5)  # Very small list\n        numbers = [random.uniform(-1e6, 1e6) for _ in range(size)]\n        space.append(numbers)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/21": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    # Simple and typical inputs\n    for i in range(25):\n        # Create a list of two to five floats within a commonly tested range\n        size = random.randint(2, 5)\n        test_case = [random.uniform(1, 100) for _ in range(size)]\n        base.append(test_case)\n\n    # Corner cases\n    # Including limits and unusual inputs that are still valid\n    for i in range(25):\n        if i % 4 == 0:\n            # Very small numbers that are not zero\n            test_case = [random.uniform(0.0001, 0.0005) for _ in range(2)]\n        elif i % 4 == 1:\n            # Large numbers to check for overflows\n            test_case = [random.uniform(1e9, 1e10) for _ in range(2)]\n        elif i % 4 == 2:\n            # Assure ascending or descending order\n            start = random.uniform(1, 50)\n            test_case = [start, start + random.uniform(0.1, 10)]\n        else:\n            # Highly similar numbers but not identical\n            base_val = random.uniform(1, 100)\n            test_case = [base_val, base_val + random.uniform(0.0001, 0.001)]\n        corner.append(test_case)\n\n    # Time complexity cases\n    # Larger inputs to test performance under load\n    for i in range(25):\n        # Increasing the size gradually for performance analysis\n        size = 50 + i * 2\n        test_case = [random.uniform(1, 1000) for _ in range(size)]\n        time.append(test_case)\n\n    # Space complexity cases\n    # Extremely large inputs to test space allocation and consumption\n    for i in range(25):\n        size = 1000 + i * 40  # very large sizes for testing memory usage\n        test_case = [random.uniform(1, 100) for _ in range(size)]\n        space.append(test_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/22": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\nimport sys\n\n\n# Function to generate test cases\ndef generate_testcases() -> (\n    Tuple[List[List[Any]], List[List[Any]], List[List[Any]], List[List[Any]]]\n):\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases (25 cases)\n    # Simple cases with mixture of integers and other types\n    for i in range(25):\n        base_case = [\n            (\n                random.randint(-100, 100)\n                if random.random() > 0.5\n                else random.choice([\"a\", 3.14, True, False, None, [], {}])\n            )\n            for _ in range(random.randint(2, 10))\n        ]\n        base.append(base_case)\n\n    # Corner Test Cases (25 cases)\n    # Cases with boundaries like large integers, only non-integers, empty lists\n    for i in range(25):\n        # Large integers\n        corner_case = [sys.maxsize, -sys.maxsize - 1]\n        # Single type non-integers\n        non_integers = [\n            random.choice([3.14, \"abc\", True, False, None, [], {}])\n            for _ in range(random.randint(2, 10))\n        ]\n        corner_case.extend(non_integers)\n        # Random shuffling to avoid pattern prediction\n        random.shuffle(corner_case)\n        corner.append(corner_case)\n\n    # Time Test Cases (25 cases)\n    # Test with large size of input list to check the performance in time\n    for i in range(25):\n        time_case = [\n            random.randint(-1000, 1000) for _ in range(1000)\n        ]  # Large list predominantly integers\n        time.append(time_case)\n\n    # Space Test Cases (25 cases)\n    # Test with deep nested structures and many elements to test memory usage\n    for i in range(25):\n        space_case = [\n            (\n                random.randint(-1000, 1000)\n                if random.random() > 0.7\n                else [random.randint(-10, 10) for _ in range(50)]\n            )\n            for _ in range(500)\n        ]\n        space.append(space_case)\n\n    return base, corner, time, space\n\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/23": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        base_length = random.randint(1, 10)  # moderate size for base cases\n        base_case = ''.join(random.choices(string.ascii_letters + string.digits, k=base_length))\n        base.append(base_case)\n\n    # Corner Cases\n    corner.append('')  # Empty string\n    corner.append('a')  # Single character\n    for _ in range(23):\n        length = random.choice([0, 1, 1000])  # focus on boundary sizes\n        corner_case = ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n        corner.append(corner_case)\n\n    # Time Complexity Cases\n    for _ in range(25):\n        time_length = 1000  # maximum size for testing time complexity\n        time_case = ''.join(random.choices(string.ascii_letters + string.digits, k=time_length))\n        time.append(time_case)\n\n    # Space Complexity Cases\n    for _ in range(25):\n        space_length = random.randint(950, 1000)  # near the maximum limit to test space complexity\n        space_case = ''.join(random.choices(string.ascii_letters + string.digits, k=space_length))\n        space.append(space_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/24": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases\n    for _ in range(25):\n        n = random.randint(2, 100)  # Choose n from 2 to 100 to ensure it is greater than 1\n        base.append(n)\n\n    # Generate corner test cases\n    corner_cases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]  # Prime numbers\n    for n in corner_cases:\n        corner.append(n)  # Using prime numbers as corner cases since their biggest divisor is 1\n\n    # Generate time complexity test cases (focus on larger numbers)\n    for _ in range(25):\n        n = random.randint(1_000_000, 10_000_000)\n        time.append(n)\n\n    # Generate space complexity test cases (focus on memory-heavy operations)\n    for _ in range(25):\n        n = random.randint(1, 1_000)  # Using smaller numbers but in large quantity might consider memory management\n        space.append(n)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/25": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        # Generating moderate size random integers\n        base.append(random.randint(10, 100))\n\n    # Corner test cases\n    for _ in range(25):\n        # Very small prime numbers and 1\n        corner.append(random.choice([1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29]))\n\n    # Time complexity test cases\n    for _ in range(25):\n        # Larger numbers to test time complexity\n        time.append(random.randint(1, 10**6))\n\n    # Space complexity test cases\n    for _ in range(25):\n        # Numbers with large prime factors\n        large_prime = random.choice([999983, 999979, 999961])\n        space.append(random.randint(1, 100) * large_prime)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/26": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    for _ in range(25):\n        n = random.randint(1, 10)\n        numbers = [random.randint(-10**9, 10**9) for _ in range(n)]\n        base.append(numbers)\n    \n    # Corner Test Cases\n    # Scenario 1: All elements same\n    corner.append([5] * 10)\n    # Scenario 2: Large numbers within the int range\n    corner.append([random.randint(10**8, 10**9) for _ in range(25)])\n    # Scenario 3: Small numbers within the int range\n    corner.append([random.randint(-10**9, -10**8) for _ in range(25)])\n    # Scenario 4: Numbers in strictly increasing order\n    corner.append(list(range(25)))\n    # Scenario 5: Numbers in strictly decreasing order\n    corner.append(list(range(25, 0, -1)))\n    # Fill remaining cases\n    for _ in range(20):\n        numbers = [random.choice([1, 2, 2, 3]) for _ in range(10)]\n        corner.append(numbers)\n    \n    # Time Complexity Test Cases\n    # Large number of elements\n    for _ in range(25):\n        n = 10000\n        numbers = [random.randint(-10**9, 10**9) for _ in range(n)]\n        time.append(numbers)\n    \n    # Space Complexity Test Cases\n    # Large diversity of elements\n    for i in range(25):\n        numbers = [(i * 999999999) % (10**9) for i in range(1000)]\n        space.append(numbers)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/27": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases (well-formed, typical examples)\n    base.append(\"Hello\")  # Given example in task description\n    base.append(\"world\")\n    base.append(\"Python3\")\n    base.append(\"12345\")    # No letters to swapcase, edge condition in normal range\n    base.append(\"HELLOworld\")  # Mixed case\n    \n    # Corner test cases (edge cases, limit conditions)\n    corner.append(\"\")  # Empty string\n    corner.append(\"a\" * 1000)  # Max size of all lowercase\n    corner.append(\"A\" * 1000)  # Max size of all uppercase\n    corner.append(\"abAB\" * 250)  # Alternating pattern at max size\n    corner.append(\" \" * 1000)  # White space only, max size\n    \n    # Time complexity test cases (large inputs)\n    for _ in range(25):\n        time.append(''.join(random.choice(string.ascii_letters) for _ in range(1000)))\n    \n    # Space complexity test cases (various sizes up to max limit)\n    for size in range(0, 1001, 50):  # Increment by 50 up to 1000\n        space.append(\"\".join(random.choice(string.ascii_letters) for _ in range(size)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/28": [
        "import random\nimport string\nfrom typing import List, Tuple, Any\n\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        base.append([random.choice(string.ascii_letters) for _ in range(random.randint(1, 10))])\n\n    # Corner cases\n    corner.append([])  # Empty list of strings\n    corner.append([\"\"])  # List of an empty string\n    corner.append([\"a\" * 1000])  # Very large single string\n    while len(corner) < 25:\n        corner.append([random.choice([\"\", \"a\", \"bbb\"]) for _ in range(random.randint(1, 3))])\n\n    # Time complexity cases\n    for _ in range(25):\n        num_strings = random.randint(50, 100)\n        time.append([''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 20))) for _ in range(num_strings)])\n\n    # Space complexity cases\n    for _ in range(25):\n        num_strings = random.randint(1, 10)\n        string_length = random.randint(1000, 2000)\n        space.append([''.join(random.choices(string.ascii_lowercase, k=string_length)) for _ in range(num_strings)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/29": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        strings = [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n        prefix = random.choice([\"a\", \"b\", \"c\", \"d\", \"e\"])\n        base.append((strings, prefix))\n\n    # Corner Cases\n    for _ in range(25):\n        # Case with an empty list of strings\n        corner.append(([], random.choice([\"z\", \"x\"])))\n\n        # Case with a list of one-letter strings and one-letter prefix\n        one_letters = [random.choice(string.ascii_lowercase) for _ in range(10)]\n        one_letter_prefix = random.choice(string.ascii_lowercase)\n        corner.append((one_letters, one_letter_prefix))\n        \n        # Case with a list of non-matching strings and a common prefix\n        mismatch_strings = [\"dog\", \"cat\", \"bat\", \"rat\"]\n        mismatch_prefix = \"z\"\n        corner.append((mismatch_strings, mismatch_prefix))\n        \n        # Case with special characters in strings and prefix\n        special_chars_strings = [\"$special\", \"%value#\", \"&data\"]\n        special_chars_prefix = \"$\"\n        corner.append((special_chars_strings, special_chars_prefix))\n\n    # Time Complexity Cases\n    for _ in range(25):\n        # Large list of strings with common prefixes to test speed\n        large_list = [random.choice([\"start\", \"stellar\", \"standard\"]) + \n                      random.choice(string.ascii_letters) * 10 for _ in range(1000)]\n        common_prefix = \"st\"\n        time.append((large_list, common_prefix))\n\n    # Space Complexity Cases\n    for _ in range(25):\n        # Large strings within a small list\n        large_strings = [random.choice(string.ascii_letters) * 1000 for _ in range(10)]\n        random_prefix = random.choice(string.ascii_letters)\n        space.append((large_strings, random_prefix))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/3": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases (normal cases, expected operations)\n    for _ in range(25):\n        num_operations = random.randint(1, 10)  # Keeping the number of operations reasonable\n        operations = [random.randint(-100, 100) for _ in range(num_operations)]\n        base.append(operations)\n\n    # Generating corner test cases (edge conditions)\n    corner.append([0] * 10)  # All zeros\n    corner.append([1] * 10)  # All positive\n    corner.append([-1] * 10)  # All negative\n    corner.append([100] * 1)  # Single large positive integer\n    corner.append([-100] * 1)  # Single large negative integer\n\n    # Extend to exactly 25 corner cases\n    while len(corner) < 25:\n        operations_length = random.randint(1, 10)\n        operations = [random.randint(-1, 0) if random.random() < 0.5 else random.randint(0, 1) for _ in range(operations_length)]\n        corner.append(operations)\n\n    # Generate time intensive test cases (stress testing)\n    for _ in range(25):\n        num_operations = 1000  # Large number of operations to test time efficiency\n        operations = [random.randint(-1000, 1000) for _ in range(num_operations)]\n        time.append(operations)\n\n    # Generate space intensive test cases (large memory usage)\n    for _ in range(25):\n        num_operations = 500  # Large operations list but not as large as time test cases\n        big_numbers = [random.randint(-10**6, 10**6) for _ in range(num_operations)]\n        space.append(big_numbers)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/30": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: mix of positive and negative numbers and zeros\n    for _ in range(25):\n        base.append([random.randint(-50, 50) for _ in range(10)])\n\n    # Corner cases: edge cases with extreme values and special arrays\n    # All zeros\n    corner.append([0] * 10)\n    # All negative\n    corner.append([random.randint(-100, -1) for _ in range(10)])\n    # Single positive\n    corner.append([random.randint(1, 100)])\n    # Empty list\n    corner.append([])\n    # Rest to make up 25\n    for _ in range(21):\n        corner.append([random.randint(-50, 50) for _ in range(random.randint(1, 5))])\n\n    # Time complexity cases: large input sizes\n    for _ in range(25):\n        time.append([random.randint(-1000, 1000) for _ in range(1000)])\n\n    # Space complexity cases: large range of numbers\n    for _ in range(25):\n        space.append([random.randint(-1000000, 1000000) for _ in range(100)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/31": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for _ in range(25):\n        base.append(random.randint(2, 100))  # Typical small to medium primes and non-primes\n\n    # Corner Cases\n    corner.append(0)  # Smallest non-negative integer, not prime\n    corner.append(1)  # Special case often mistaken as prime\n    corner.append(2)  # Smallest prime number\n    while len(corner) < 25:\n        corner.append(random.randint(-10, 1)) # Additional non-prime small values\n\n    # Time Complexity Cases\n    for _ in range(25):\n        time.append(random.randint(1_000_000, 10_000_000))  # Large numbers to test time complexity\n\n    # Space Complexity Cases\n    for _ in range(25):\n        space.append(2**random.randint(5, 20))  # Powers of two, typically hard for some naive prime checks\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/32": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases \n    for _ in range(25):\n        # Simple cases: small polynomials with clear roots\n        coeffs = [random.randint(-10, 10) for _ in range(2)]\n        coeffs[-1] = random.randint(1, 10)  # ensuring the last coefficient is non-zero\n        base.append(coeffs)\n    \n    # Corner cases\n    for _ in range(25):\n        # Cases that might cause rounding errors or precision issues\n        coeffs = [random.random() * 10 for _ in range(4)]  # using floating point numbers\n        coeffs[-1] = random.random() * 10 + 1  # ensuring last coefficient remains non-zero and adds precision challenges\n        corner.append(coeffs)\n    \n    # Time complexity cases\n    for _ in range(25):\n        # Larger polynomials to test performance under 'normal' operation conditions\n        n_coeff = random.randint(6, 12)  # Even number of coefficients between 6 and 12\n        coeffs = [random.randint(-100, 100) for _ in range(n_coeff)]\n        coeffs[-1] = random.randint(1, 100)  # ensure the last coefficient is non-zero\n        time.append(coeffs)\n\n    # Space complexity cases\n    for _ in range(25):\n        # Huge number of coefficients to test space efficiency and limits\n        n_coeff = random.randint(14, 20)  # Even number of coefficients between 14 and 20\n        coeffs = [random.randint(-1000, 1000) for _ in range(n_coeff)]\n        coeffs[-1] = random.randint(1, 1000)  # ensure the last coefficient is non-zero\n        space.append(coeffs)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/33": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        n = random.randint(5, 10)  # Moderate size for readability\n        base.append([random.randint(1, 100) for _ in range(n)])\n\n    # Corner cases\n    # These will test small arrays and special element cases\n    corner.append([])  # Empty list\n    corner.append([1])  # Single element list\n    corner.append([1, 2, 3])  # Exactly one set of third elements\n    corner.append([1, 2, 3, 4, 5, 6])  # Exactly two sets of third elements\n    corner.append([3, 2, 1] + [random.randint(1, 100) for _ in range(50)])  # Sorting needed at start\n\n    # Time complexity cases\n    # Large arrays to check performance\n    for _ in range(25):\n        n = random.randint(1000, 2000)\n        time.append([random.randint(1, 1000) for _ in range(n)])\n\n    # Space complexity cases\n    # Large arrays and also consider large numbers\n    for _ in range(25):\n        n = random.randint(1000, 2000)\n        space.append([random.randint(1, 100000) for _ in range(n)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/34": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # A small list of elements\n        base.append([random.randint(0, 100) for _ in range(length)])\n\n    # Corner Cases\n    corner.append([])  # Empty list\n    corner.append([1])  # Single element\n    corner.append([2, 2, 2, 2, 2, 2, 2])  # All elements the same\n    corner.extend([[i] * random.randint(1, 3) for i in range(22)])  # Multiple lists with the same repeated element\n\n    # Time Cases\n    for _ in range(25):\n        length = random.randint(100, 1000)  # Large number of elements\n        time.append([random.randint(0, 10000) for _ in range(length)])\n\n    # Space Cases\n    for _ in range(25):\n        length = random.randint(50, 200)  # Moderately large lists\n        num_unique = random.randint(1, length // 2)  # Some guaranteed unique numbers\n        space_case = [random.randint(0, length) for _ in range(length - num_unique)]\n        space_case.extend(range(num_unique))\n        random.shuffle(space_case)\n        space.append(space_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/35": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases: Simple and straightforward test cases\n    for i in range(25):\n        n = random.randint(1, 10)  # A small list size from 1 to 10\n        test_case = [random.randint(-100, 100) for _ in range(n)]\n        base.append(test_case)\n\n    # Corner Test Cases: Edge scenarios\n    for i in range(25):\n        # Test case where all elements are the same\n        n = random.randint(1, 10)\n        same_element = random.randint(-100, 100)\n        test_case = [same_element] * n\n        corner.append(test_case)\n\n        # Test case with only one element\n        single_element = [random.randint(-100, 100)]\n        corner.append(single_element)\n\n    # Ensure 25 actual corner test cases\n    corner = corner[:25]\n\n    # Time Complexity Test Cases: Large inputs to test efficiency\n    for i in range(25):\n        n = random.randint(1000, 10000)  # Large list size for performance testing\n        test_case = [random.randint(-1000, 1000) for _ in range(n)]\n        time.append(test_case)\n\n    # Space Complexity Test Cases: Large memory usage or structure\n    for i in range(25):\n        n = random.randint(500, 1000)  # Large but slightly less than time complexity test cases\n        test_case = [random.randint(-100, 100) for _ in range(n)]\n        space.append(test_case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/36": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.extend([1, 2, 3, 10, 20, 50])  # Simple divisible numbers and cases with one digit\n\n    # Corner cases\n    corner.append(7)  # First number divisible by neither 11 nor 13 but including '7'\n    corner.append(77) # Number divisible by 11 and contains '7'\n    corner.append(13) # First number divisible by 13\n    corner.append(11) # First number divisible by 11\n    corner.append(143) # First common multiple of 11 and 13\n\n    # Time complexity cases\n    n = 1000\n    while len(time) < 25:\n        time.append(n)\n        n += 1000  # Incrementing to ensure large inputs\n\n    # Space complexity cases\n    n = 1002\n    while len(space) < 25:\n        space.append(n)\n        n += 1000  # Similar strategy to time, but starts at a different point\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/37": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - Simple scenarios\n    for _ in range(25):\n        n = random.randint(5, 10)\n        test_list = [random.randint(1, 100) for __ in range(n)]\n        base.append(test_list)\n\n    # Corner cases - Edge and special scenarios\n    corner.append([])  # Empty list\n    corner.append([1])  # Single item\n    corner.append([2, 1])  # Two items, reverse order\n    corner.append([3]*random.randint(2, 5))  # All elements the same\n\n    # Generate more diverse corner cases\n    while len(corner) < 25:\n        n = random.randint(5, 10)\n        test_list = [random.randint(-100, 100) if random.random() < 0.5 else random.randint(1, 10) for __ in range(n)]\n        if random.random() < 0.5:\n            test_list.sort()  # Strictly sorted list\n        if random.random() < 0.3:\n            test_list = sorted(test_list, reverse=True)  # Strictly reverse sorted list\n        corner.append(test_list)\n\n    # Time complexity cases - Large arrays for testing execution speed\n    for _ in range(25):\n        n = random.randint(10000, 50000)\n        test_list = [random.randint(1, 1000) for __ in range(n)]\n        time.append(test_list)\n\n    # Space complexity cases - Large arrays to test memory usage\n    for _ in range(25):\n        n = random.randint(20000, 100000)\n        test_list = [random.randint(0, 100) for __ in range(n)]\n        space.append(test_list)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/38": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        base.append('abc' * random.randint(1, 10))  # generates multiple groups of 'abc'\n\n    # Corner cases\n    corner.append('')  # empty string\n    corner.append('ab')  # less than 3 characters\n    corner.append('abc')  # exactly one group\n    for _ in range(22):\n        # strings with 1 or 2 characters less than multiple of 3\n        num_groups = random.randint(1, 10)\n        corner.append('abc' * num_groups + ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 2))))\n\n    # Time complexity cases\n    for _ in range(25):\n        # Long strings to test time complexity\n        time.append(''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase + string.digits, k=random.randint(900, 1000))))\n\n    # Space complexity cases\n    for _ in range(25):\n        # Strings close to the max allowed length to test space usage\n        space.append(''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase + string.digits, k=1000)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/39": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case Tests\n    # Reasonable values around which the function is expected to operate correctly.\n    base.extend([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n    # Corner Case Tests\n    # Very small and potentially tricky values\n    corner.extend([1, 2, 3])\n\n    # Time Complexity Tests\n    # Large values to test the efficiency of the algorithm in terms of time (may lead to long execution time).\n    time.extend([1 + i for i in range(20)])\n\n    # Space Complexity Tests\n    # Values that are repetitive or structured to potentially exploit weaknesses in space usage.\n    space.extend([1 + i for i in range(20)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/4": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - simple, straightforward test cases\n    for i in range(25):\n        n = random.randint(1, 10)  # Number of elements: between 1 and 10\n        testcase = [random.uniform(-100.0, 100.0) for _ in range(n)]  # Generate n floats within -100 to 100\n        base.append(testcase)\n\n    # Corner cases - edge values and minimal/maximal values\n    # Single element test cases\n    corner.append([random.uniform(-1e6, 1e6) for _ in range(1)] * 5)  # Five test cases with a single large/small float\n\n    # Small and large values\n    for _ in range(15):\n        n = random.randint(1, 10)\n        if _ % 2 == 0:\n            testcase = [random.uniform(-1e-12, 1e-12) for _ in range(n)]  # Small floats close to zero\n        else:\n            testcase = [random.uniform(-1e12, 1e12) for _ in range(n)]  # Large floats\n        corner.append(testcase)\n\n    # Time complexity related cases - test the efficiency with higher input sizes\n    for _ in range(25):\n        n = random.randint(1000, 2000)  # Large number of elements\n        testcase = [random.uniform(-1000.0, 1000.0) for _ in range(n)]\n        time.append(testcase)\n\n    # Space complexity related cases - test the memory usage and management with bulky inputs\n    for _ in range(25):\n        n = random.randint(5000, 10000)  # Very large number of elements\n        testcase = [random.uniform(-100.0, 100.0) for _ in range(n)]\n        space.append(testcase)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/40": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base case test scenarios\n    for _ in range(25):\n        length = random.randint(3, 10)  # A reasonable size for basic testing\n        base.append([random.randint(-10, 10) for _ in range(length)])\n    \n    # Corner case test scenarios\n    # Minimal input size of 3 elements\n    corner.append([0, 0, 0])  # Case where all elements are zeros\n    corner.append([1, 2, -3])  # Case where one valid triplet exists\n    # Adding multiple triplets that sum to zero\n    corner.append([3, -1, -2, 3, 1, -4, 0, 0, 0])\n    # No possible triplet\n    corner.append([1, 1, 1])\n    # Large numbers\n    corner.append([1000, -1000, 0])\n\n    # Time complexity test scenarios\n    # Large inputs to challenge the algorithm\n    for _ in range(25):\n        large_length = random.randint(100, 200)  # Larger array size\n        time.append([random.randint(-1000, 1000) for _ in range(large_length)])\n    \n    # Space complexity test scenarios\n    # Large inputs with no valid triplet to ensure full traversal is required\n    for _ in range(25):\n        large_length = random.randint(100, 200)\n        # Large input with high likelihood of no zero-sum triplets\n        space.append([random.randint(1, 1000) for _ in range(large_length)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/41": [
        "# Import statements\nfrom typing import Tuple, List, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Simple and typical inputs\n    base.extend([1, 2, 5, 10, 20])  # Reasonable small-sized inputs\n\n    # Corner Cases: Edge inputs testing the boundaries\n    corner.append(0)  # No cars, should result in no collisions\n    corner.append(2147483647)  # Maximum 32-bit signed integer value, testing large input\n\n    # Generate more corner cases\n    for _ in range(23):\n        corner.append(random.randint(1, 100))  # Smaller values to still test limits but feasible in execution\n\n    # Time Complexity Cases: Inputs that are meant to be computationally intensive\n    time.extend([1000] * 25)  # Large inputs that are uniform to test the scalability\n\n    # Space Complexity Cases: Inputs designed to test the limits of memory usage\n    # Here, since the function is input in size and does not store additional data structures, it's less relevant,\n    # but we still assume the function might have implemented some memory structures internally.\n    space.extend([500, 1000, 1500, 2000, 2500])\n\n    # Generate more space cases\n    for _ in range(20):\n        space.append(random.randint(300, 3000))  # Large numbers within a moderate range\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/42": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        simple_case = [random.randint(0, 10) for _ in range(5)]\n        base.append(simple_case)\n\n    # Corner Cases\n    # Test with empty list\n    corner.append([])\n    # Test with list of size one\n    corner.append([random.randint(0, 10)])\n    # Test with largest lists but few elements\n    corner.extend([random.sample(range(100), k=3) for _ in range(23)])\n\n    # Time Complexity Cases\n    # Creating large lists to check the performance in terms of time\n    # Here we incrementally increase the size of the lists\n    for i in range(25):\n        large_input = [random.randint(0, 1000) for _ in range((i + 1) * 100)]\n        time.append(large_input)\n\n    # Space Complexity Cases\n    # Creating heavy lists that are large in size\n    for _ in range(25):\n        heavy_input = [random.randint(0, 10000) for _ in range(1000)]\n        space.append(heavy_input)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/43": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases - typical scenarios including pairs that sum to zero and those that do not\n    base.append([1, -1])  # Simplest case with a direct match\n    base.append([1, 2, 3, -3])  # Multiple elements, with one pair summing to zero\n    base.append([0, 0])  # Pair of zeros\n    base.append([-5, 5, 10, -10, 15])  # Multiple pairs\n    base.append([])  # Empty list, should return False\n    for _ in range(20):\n        base.append(random.sample(range(-100, 100), 10))  # Variety of random lists\n\n    # Corner Cases - edge cases challenging the function\n    corner.append([1])  # Single element, can't pair\n    corner.append([10**6, -10**6])  # Extreme values\n    corner.append([0])  # Single zero\n    corner.append([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -1, -2, -3, -4, -5])  # No pair sums to zero\n    for i in range(20):\n        corner.append([random.randint(-100, 100) for _ in range(1)])  # Single random integers\n    \n    # Time Complexity Cases - large inputs to test efficiency\n    time.append(list(range(-1000, 1000)))  # Large range of distinct integers\n    time.append(list(range(-500, 500)) * 2 + [0, 0])  # Larger lists with duplicates\n    for _ in range(23):\n        sz = random.randint(950, 1050)\n        time.append(random.sample(range(-10000, 10000), sz))  # Random large lists\n    \n    # Space Complexity Cases - designed to test memory usage\n    space.append([0] * 10000)  # Large number of a single element\n    space.append(list(range(-5000, 5000)))  # Large unique list\n    for _ in range(23):\n        size = random.randint(9000, 11000)\n        space.append([random.randint(-1, 1) for _ in range(size)])  # Lists of -1, 0, 1\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/44": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for i in range(25):\n        x = random.randint(1, 1000)\n        base_b = random.randint(2, 9)\n        base.append((x, base_b))\n    \n    # Corner cases\n    # Test lower limit of range\n    corner.append((0, 2))  # x at minimum value with smallest base\n    corner.append((0, 9))  # x at minimum value with largest base\n    corner.append((1, 2))  # smallest x > 0 with smallest base\n    corner.append((1, 9))  # smallest x > 0 with largest base\n    corner.append((1000, 2))  # large x with smallest base\n    corner.append((1000, 9))  # large x with largest base\n\n    # Fill remaining corner cases\n    while len(corner) < 25:\n        x = random.choice([0, 1, 999, 1000])  # focusing on edge integers\n        base_b = random.choice([2, 9])  # focusing on edge bases\n        corner.append((x, base_b))\n    \n    # Time complexity cases (larger numbers to challenge computation times)\n    for i in range(25):\n        x = random.randint(10000, 100000)\n        base_b = random.randint(2, 9)\n        time.append((x, base_b))\n    \n    # Space complexity cases (repeated base conversions for the same number)\n    # Using multiple conversions of the same number\n    x = 12345\n    for i in range(25):\n        base_b = random.randint(2, 9)\n        space.append((x, base_b))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/45": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases\n    for _ in range(25):\n        a = random.randint(1, 100)\n        h = random.randint(1, 100)\n        base.append((a, h))\n\n    # Generate corner test cases\n    # Testing with minimum positive allowed values and edge cases\n    corner.append((1, 1))  # smallest positive integers\n    for _ in range(24):\n        a = random.uniform(0.1, 1.0)  # small float edge cases\n        h = random.uniform(0.1, 1.0)\n        corner.append((a, h))\n\n    # Generate time complexity test cases\n    # Large values to test performance\n    for _ in range(25):\n        a = random.randint(1000, 10000)\n        h = random.randint(1000, 10000)\n        time.append((a, h))\n\n    # Generate space complexity test cases\n    # Similar to time cases but to test if handling large data causes memory issues\n    for _ in range(25):\n        a = random.randint(1000, 10000)\n        h = random.randint(1000, 10000)\n        space.append((a, h))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/46": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - typical small numbers\n    base.extend([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n    # Corner cases - edge and special numbers\n    corner.append(0)  # Lowest possible value\n    corner.append(1)  # Another base case to check\n    corner.append(2)  # Start of custom computation pattern\n    corner.append(3)  # Last before general case\n    corner.append(4)  # First general case (where n-4 is valid)\n    corner.append(20) # A larger number that is often a typical limit in tests\n    for i in range(15):\n        corner.append(random.randint(5, 100))  # Random medium-sized numbers to challenge the transition points\n\n    # Time challenges - largest values to test for time complexity\n    time.extend([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])\n\n    # Space challenges - increasing numbers to test space complexity\n    space.extend([i for i in range(100, 1001, 100)])  # Increasing space complexity in steps of 100\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/47": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base case generation\n    for _ in range(25):\n        n = random.randint(1, 20)  # Generate lists of varying small to moderate sizes\n        numbers = [random.randint(1, 100) for _ in range(n)]\n        base.append(numbers)\n\n    # Corner case generation\n    for _ in range(25):\n        # Generate lists of small size but with extreme values\n        extreme_values = [random.choice([-1e6, 1e6]) for _ in range(2)]  # Minimum size list but with large values\n        corner.append(extreme_values)\n        # Single element lists\n        single_element = [random.randint(-1000, 1000)]\n        corner.append(single_element)\n        # Sorted and reverse sorted lists to test boundary condition handling in median calculation\n        sorted_list = sorted([random.randint(-100, 100) for _ in range(5)])\n        corner.append(sorted_list)\n        reverse_sorted_list = sorted_list[::-1]\n        corner.append(reverse_sorted_list)\n\n    # Time complexity case generation\n    for _ in range(25):\n        # Large size lists to test execution time performance\n        large_numbers = [random.randint(-1000, 1000) for _ in range(1000)]\n        time.append(large_numbers)\n\n    # Space complexity case generation\n    for _ in range(25):\n        # Very large lists with moderate values to test memory usage\n        very_large_numbers = [random.choice([0, 1, -1]) for _ in range(100000)]\n        space.append(very_large_numbers)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/48": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases: common simple palindromes and non-palindromes\n    base.append('')  # empty string\n    base.append('a')  # single character\n    base.append('radar')  # typical palindrome\n    base.append('hello')  # typical non-palindrome\n\n    # Generate more base cases to cover normal scenarios\n    for i in range(1, 25):\n        base.append('a' * i)  # strings of the same character (palindrome)\n        base.append('a' * i + 'b')  # similar string with one differing character at the end\n\n    # Corner test cases: edge cases that might affect performance or correctness\n    corner.append('a' * 1000)  # largest palindrome under constraints\n    corner.append('a' * 999 + 'b')  # long string, non-palindrome by one character\n    corner.append('racecar')  # odd length palindrome\n    corner.append('deified')  # odd length palindrome\n\n    # Generate challenging corner cases\n    for i in range(10):\n        # even length non-palindrome\n        corner.append('b' * 500 + 'a' * 500)\n        # palindrome with spaces\n        corner.append('nurses run'.replace(' ', ''))\n\n    # Time complexity test cases: cases designed to test performance limits\n    for i in range(25):\n        # maximum allowed lengths\n        text = 'xy' * 500  # ensures non-palindrome, alternating characters\n        time.append(text)\n\n    # Space complexity test cases: cases designed to utilize memory\n    for i in range(25):\n        # strings that are close to the maximum allowable length\n        if i % 2 == 0:\n            space.append('p' * 1000)  # palindrome\n        else:\n            space.append('q' * 999 + 'r')  # non-palindrome\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/49": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base cases\n    base.append((3, 5))\n    base.append((1101, 101))\n    base.append((0, 101))\n    base.append((3, 11))\n    base.append((100, 101))\n    base.extend([(i, 101) for i in range(20)])  # A range of smaller integers\n\n    # Generating corner cases\n    corner.append((0, 1))  # As the smallest positive integer for p\n    corner.append((1000000, 2))  # Large n with smallest p > 1\n    corner.append((1, 1000000007))  # Prime number p\n    corner.append((0, 2))  # Edge case for zero power\n    corner.extend([(1, p) for p in range(2, 26)])  # p varying from 2 to 25\n\n    # Generating time complexity cases\n    for _ in range(25):\n        n = random.randint(100000, 1000000)  # Large values of n\n        p = random.randint(10000, 100000)  # Large values of p\n        time.append((n, p))\n\n    # Generating space complexity cases\n    for _ in range(25):\n        n = random.randint(1, 100)  # Smaller values of n, large computations\n        p = random.randint(100000000, 200000000)  # Very large values of p\n        space.append((n, p))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/5": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        numbers = [random.randint(-10, 10) for _ in range(5)]\n        delimiter = random.randint(-5, 5)\n        base.append((numbers, delimiter))\n    \n    # Corner Cases\n    corner.append(([], 1))  # Empty list case\n    corner.append(([0], 1))  # Single element case\n    corner.append(([1, 2], 0))  # Delimiter as zero\n    corner.append(([-1, -2, -3], -5))  # All negative numbers\n    while len(corner) < 25:\n        numbers = [random.randint(-10, 10) for _ in range(3)]\n        delimiter = random.randint(-5, 5)\n        corner.append((numbers, delimiter))\n    \n    # Time Complexity Cases\n    for _ in range(25):\n        numbers = [random.randint(-1000, 1000) for _ in range(200)]\n        delimiter = random.randint(-100, 100)\n        time.append((numbers, delimiter))\n    \n    # Space Complexity Cases\n    for _ in range(25):\n        numbers = [random.randint(-200, 200) for _ in range(100)]\n        delimiter = random.randint(-50, 50)\n        space.append((numbers, delimiter))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/50": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # modest length\n        test_string = ''.join(random.choices(string.ascii_lowercase, k=length))\n        base.append(test_string)\n\n    # Corner cases\n    corner.append('a' * 100)  # Edge case of a single character repeated\n    corner.append('z' * 100)  # Edge case of a single character repeated at the end of the alphabet\n    corner.append(''.join([chr(i) for i in range(97, 123)]))  # Sequence from 'a' to 'z'\n    corner.append(''.join([chr(i) for i in range(122, 96, -1)]))  # Reverse sequence from 'z' to 'a'\n    while len(corner) < 25:\n        length = random.randint(1, 100)  # longer strings for more corner cases\n        test_string = ''.join(random.choices(string.ascii_lowercase, k=length))\n        corner.append(test_string)\n\n    # Time complexity cases\n    for _ in range(25):\n        length = random.randint(100, 1000)  # very long strings to test time efficiency\n        test_string = ''.join(random.choices(string.ascii_lowercase, k=length))\n        time.append(test_string)\n\n    # Space complexity cases\n    for _ in range(25):\n        length = random.randint(100, 500)  # large strings to test space usage\n        test_string = ''.join(random.choices(string.ascii_lowercase, k=length))\n        space.append(test_string)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/51": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append(\"\")  # Empty string\n    base.append(\"abcdef\")  # String with vowels at the beginning, middle, and end\n    base.append(\"1234567890\")  # Numbers\n    base.append(\"!@#$%^&*()\")  # Special characters\n    base.append(\"abcdef\\nghijklm\")  # String with newline character\n    while len(base) < 25:\n        base.append(''.join(random.choices(string.ascii_letters + string.digits + \" \\n\\t\", k=20)))  # Random strings\n\n    # Corner cases\n    corner.append(\"a\" * 100)  # String with only 'a' character\n    corner.append(\"AAA\" * 100)  # String with only 'A' character\n    corner.append(\"zbcd\" * 100)  # String without any vowels\n    corner.append(\"aaaaa\" * 20)  # String with only vowels\n    corner.append(\"\\n\\t\" * 50)  # String of newline and tab characters\n    while len(corner) < 25:\n        pattern = random.choice([\"aeiou\", \"AEIOU\", \"bcdfg\", \"BCDFG\"]) * 20\n        corner.append(pattern)  # Repetitive vowel/non-vowel patterns\n\n    # Time complexity cases\n    while len(time) < 25:\n        n = random.randint(50, 200)\n        time.append(''.join(random.choices(string.ascii_letters + string.digits, k=n)))  # Longer strings for time complexity\n\n    # Space complexity cases\n    while len(space) < 25:\n        n = random.randint(1, 50)  # Varied lengths to test memory usage over different input sizes\n        space.append(''.join(random.choices(\"aeiouAEIOU\" + string.ascii_letters, k=n)))  # Mixed cases of vowels and consonants\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/52": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        # Regular small to moderate size list with various threshold values\n        l = [random.randint(1, 50) for _ in range(random.randint(1, 10))]\n        t = random.randint(1, 100)\n        base.append((l, t))\n\n    # Corner cases\n    for _ in range(25):\n        # Single element list cases\n        single_element = [random.randint(1, 20)]\n        thresholds = [random.randint(0, 30) for _ in range(5)]\n        corner.extend([(single_element, th) for th in thresholds])\n\n        # Maximum vs minimum int values in list with tight threshold\n        max_int = [random.randint(100, 1000)]\n        min_int_threshold = max_int[0] - 1\n        corner.append((max_int, min_int_threshold))\n\n        # All elements are the same with threshold equal to the value\n        same_elements = [5] * random.randint(1, 5)\n        corner.append((same_elements, 5))\n\n    # Time complexity cases\n    for _ in range(25):\n        # Large lists with moderately safe threshold to not hit the boundary often\n        large_list = [random.randint(1, 10000) for _ in range(1000)]\n        large_threshold = random.randint(5000, 15000)\n        time.append((large_list, large_threshold))\n\n    # Space complexity cases\n    for _ in range(25):\n        # Very large list with very large threshold\n        very_large_list = [random.randint(1, 100000) for _ in range(10000)]\n        very_large_threshold = random.randint(50000, 200000)\n        space.append((very_large_list, very_large_threshold))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/53": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - general use\n    for i in range(25):\n        x = i\n        y = i + 1\n        base.append((x, y))\n\n    # Corner cases - extremes and borderline values\n    corner.append((0, 0))  # Adding zeros\n    corner.append((-1, -1))  # Negative numbers\n    corner.append((1, -1))  # Positive and negative\n    corner.append((1000000000, 1000000000))  # Large numbers\n    for i in range(20):\n        corner.append((i, -i))  # Balanced positive and negative numbers\n\n    # Time complexity cases - large numbers to test time efficiency\n    for i in range(50):\n        time.append((i * 10000, i * 10000))  # Sequentially larger values\n\n    # Space complexity cases - same number to test for simplicity in memory usage patterns\n    for i in range(25):\n        space.append((123456789, 123456789))  # Large constant to use more space\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/54": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]], List[Tuple[str, str]]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Helper function to generate a random string of given length\n    def random_string(length: int) -> str:\n        return ''.join(random.choices(string.ascii_lowercase + string.ascii_uppercase, k=length))\n\n    # Base cases - Simple cases where strings might have the exact or no characters in common\n    for _ in range(25):\n        base_str_len = random.randint(1, 10)\n        s0 = random_string(base_str_len)\n        s1 = random_string(base_str_len)\n        base.append((s0, s1))\n\n    # Corner cases - Boundary conditions and edge cases\n    # Case where strings are at maximum length\n    max_str = random_string(1000)\n    corner.append((max_str, max_str))\n    # Case where strings are minimal but different\n    for _ in range(24):\n        s0 = random_string(1)\n        s1 = random_string(1)\n        while s0 == s1:\n            s1 = random_string(1)\n        corner.append((s0, s1))\n\n    # Time complexity cases - cases that push the runtime, close to the input limit\n    for _ in range(25):\n        length = random.randint(500, 1000)\n        s0 = random_string(length)\n        s1 = random_string(length)\n        time.append((s0, s1))\n\n    # Space complexity cases - cases that emphasize memory usage, including maximum length variations\n    for _ in range(25):\n        length = 1000\n        s0 = random_string(length)\n        s1 = random_string(length)\n        space.append((s0, s1))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/55": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for i in range(25):\n        base.append(i)  # Basic cases from 0 to 24\n\n    # Corner cases\n    corner.append(0)  # Smallest possible value\n    corner.append(1)  # Second smallest, significant in fib sequence\n    for i in range(2, 27):\n        corner.append(i)  # Next set of values, testing early returns and early sequence values\n\n    # Time complexity cases\n    for i in range(100, 125):\n        time.append(i)  # Large values to test time performance\n\n    # Space complexity cases\n    for i in range(500, 525):\n        space.append(i)  # Very large values to test space usage\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/56": [
        "# Import statements\nfrom typing import List, Tuple, Any\nfrom random import choice\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases - balanced and simple cases\n    base.append(\"<>\")\n    base.append(\"<<>>\")\n    for _ in range(23):\n        n = choice(range(1, 10))  # Limit size for simplicity\n        balanced = \"<\" * n + \">\" * n\n        base.append(balanced)\n\n    # Corner Cases - tricky edge cases\n    corner.append(\"<\")   # Single opening\n    corner.append(\">\")   # Single closing\n    corner.append(\"><\")  # Closing before opening\n    for _ in range(22):\n        n = choice(range(1, 10))\n        unbalanced = \"<\" * (n + 1) + \">\" * n  # More opening than closing\n        corner.append(unbalanced)\n\n    # Time Complexity Cases - larger inputs to test performance\n    for _ in range(25):\n        n = choice(range(100, 1000))  # Large ranges\n        half_n = n // 2\n        large_balanced = \"<\" * half_n + \">\" * half_n\n        time.append(large_balanced)\n\n    # Space Complexity Cases - Memory usage testing by depth and patterns\n    for _ in range(25):\n        pattern = choice([\"<>\", \"<><>\", \"<<>>\"]) * choice(range(50, 100))\n        space.append(pattern)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/57": [
        "from typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for i in range(25):\n        if i % 2 == 0:\n            # Generating a random monotonically increasing list\n            start = random.randint(-100, 100) \n            end = start + random.randint(1, 10)\n            step = random.randint(1, 5)\n            base.append(list(range(start, end, step)))\n        else:\n            # Generating a random monotonically decreasing list\n            start = random.randint(-100, 100) \n            end = start - random.randint(1, 10)\n            step = random.randint(1, 5)\n            base.append(list(range(start, end, -step)))\n    \n    # Corner Cases\n    corner.append([])  # Empty list\n    corner.append([5])  # Single element list\n    for _ in range(23):\n        number = random.randint(-100, 100)\n        length = random.randint(2, 10)\n        repeated_list = [number] * length\n        corner.append(repeated_list)  # List with repeated elements\n\n    # Time Complexity Cases\n    for i in range(25):\n        size = 1000 + i * 10  # Incrementally increasing the size\n        list_type = i % 2\n        if list_type == 0:\n            start = random.randint(-10000, 10000)\n            step = random.randint(1, 10)\n            time.append(list(range(start, start + size * step, step)))\n        else:\n            start = random.randint(-10000, 10000)\n            step = random.randint(1, 10)\n            time.append(list(range(start, start - size * step, -step)))\n\n    # Space Complexity Cases (Creating Large Lists with Simple Repeated Patterns)\n    for _ in range(25):\n        size = random.randint(5000, 10000)  # Large size\n        element = random.randint(-100, 100)\n        space_list = [element] * size\n        space.append(space_list)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/58": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        l1 = [random.randint(1, 100) for _ in range(random.randint(1, 10))]\n        l2 = [random.randint(1, 100) for _ in range(random.randint(1, 10))]\n        base.append((l1, l2))\n\n    # Corner cases\n    for _ in range(25):\n        # Single element both lists\n        single_element = random.randint(1, 100)\n        l1 = [single_element]\n        l2 = [single_element]\n        corner.append((l1, l2))\n        \n        # No common elements\n        l1 = [random.randint(1, 50) for _ in range(5)]\n        l2 = [random.randint(51, 100) for _ in range(5)]\n        corner.append((l1, l2))\n        \n        # Lists where one list is empty\n        l1 = []\n        l2 = [random.randint(1, 100) for _ in range(random.randint(1, 10))]\n        corner.append((l1, l2))\n        \n        # Large numbers\n        l1 = [random.randint(1000, 2000) for _ in range(5)]\n        l2 = [random.randint(1000, 2000) for _ in range(5)]\n        corner.append((l1, l2))\n\n    # Time complexity cases\n    for _ in range(25):\n        large_size = random.randint(5000, 10000)\n        l1 = [random.randint(1, large_size) for _ in range(large_size)]\n        l2 = [random.randint(1, large_size) for _ in range(large_size)]\n        time.append((l1, l2))\n\n    # Space complexity cases\n    for _ in range(25):\n        very_large_size = random.randint(100000, 200000)\n        l1 = [random.randint(1, very_large_size) for _ in range(very_large_size)]\n        l2 = [random.randint(1, very_large_size) for _ in range(very_large_size)]\n        space.append((l1, l2))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/59": [
        "# Import statements\nfrom typing import Tuple, List, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Helper function to generate a non-prime number greater than 1\n    def generate_non_prime(min_val, max_val):\n        while True:\n            num = random.randint(min_val, max_val)\n            if not is_prime(num):\n                return num\n\n    # Helper function to check if a number is prime\n    def is_prime(num):\n        if num <= 1:\n            return False\n        if num <= 3:\n            return True\n        if num % 2 == 0 or num % 3 == 0:\n            return False\n        i = 5\n        while i * i <= num:\n            if num % i == 0 or num % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    # Base Test Cases: General cases with small non-prime numbers\n    for _ in range(25):\n        base.append(generate_non_prime(4, 100))\n\n    # Corner Test Cases: Edge non-prime numbers just above 1, and very small non-primes\n    corner.append(4)   # Smallest composite number\n    for _ in range(24):\n        corner.append(generate_non_prime(2, 10))\n\n    # Time Complexity Test Cases: Large inputs to test efficiency\n    for _ in range(25):\n        time.append(generate_non_prime(10000, 100000))\n\n    # Space Complexity Test Cases: Very large inputs to test memory usage\n    for _ in range(25):\n        space.append(generate_non_prime(1000000, 10000000))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/6": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for i in range(25):\n        base.append(\"(())\" * (i + 1))  # Variable number of simple nested pairs\n\n    # Corner Cases\n    corner.append('')  # Empty input\n    corner.append('()')  # Smallest non-empty case\n    for i in range(23):\n        if i % 2 == 0:\n            corner.append(\"(\" * (i + 2) + \")\" * (i + 2))  # Balanced deep nesting\n        else:\n            corner.append(\"(()\" * (i + 2) + \")\" * (i + 2))  # Nested and sequential mix\n\n    # Time Complexity Cases\n    long_string = \"(\" * 50 + \")\" * 50\n    for i in range(25):\n        time.append(long_string)  # Same long input to test execution time\n\n    # Space Complexity Cases\n    varied_depths = \" \".join([\"(\" * (i % 10 + 1) + \")\" * (i % 10 + 1) for i in range(50)])\n    for i in range(25):\n        space.append(varied_depths)  # String with varied depths of parentheses\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/60": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Common straightforward cases\n    base += [i for i in range(1, 26)]\n\n    # Corner cases: Minimum, maximum, and some slightly unusual yet valid values\n    corner += [1, 2, 99999, 100000]  # assuming 100,000 as an upper reasonable constraint\n    corner += [random.randint(10, 100) for _ in range(21)]  # extra random values\n\n    # Time complexity cases: Large values to check performance under load\n    time += [random.randint(10000, 20000) for _ in range(25)]\n\n    # Space complexity cases: Just test with max values close to assumed limit\n    space += [random.randint(80000, 100000) for _ in range(25)]\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/61": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Test with simple combinations\n    base.append(\"()\")\n    base.append(\"(())\")\n    base.append(\"((()))\")\n    base.append(\"()()()\")\n    base.extend([\"()\"] * 21)  # Ensure exactly 25 test cases for base type\n\n    # Corner Cases: Test with edge cases and tricky combinations\n    corner.append(\"(\")  # Single open bracket\n    corner.append(\")\")  # Single close bracket\n    corner.append(\")(\")  # Wrong order of brackets\n    corner.append(\"(((((((((((((((((((((((\")  # Many opens\n    corner.append(\")))))))))))))))))))))))\")  # Many closes\n    for i in range(20):\n        corner.append(\"(\" * (i + 1) + \")\" * i)  # Always missing one closing bracket\n\n    # Time Complexity Cases: Very large inputs to test efficiency\n    for i in range(25):\n        time.append(\"(\" * 50 + \")\" * 50)  # Balanced but large\n\n    # Space Complexity Cases: Large inputs with minimal complexity\n    for i in range(25):\n        if i % 2 == 0:\n            space.append((\"()\" * 50))  # Repeated small balanced brackets\n        else:\n            space.append((\"(\" * 50 + \")\") * 50)  # Long string of balanced brackets\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/62": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate Base Test Cases\n    for _ in range(25):\n        n = random.randint(2, 5)  # small polynomial degree to check basic behavior\n        base.append([random.randint(-10, 10) for _ in range(n)])\n\n    # Generate Corner Test Cases\n    for _ in range(25):\n        # Include zero coefficients and high coefficients\n        n = random.randint(2, 5)\n        if _ % 2 == 0:\n            # Generate test case with zeros, which could lead to a sparse derived polynomial\n            corner.append([random.choice([0, random.randint(-10, 10)]) for _ in range(n)])\n        else:\n            # Generate test case with potentially large numbers\n            corner.append([random.randint(-100, 100) for _ in range(n)])\n\n    # Generate Time Complexity Test Cases\n    for _ in range(25):\n        n = random.randint(50, 100)  # larger polynomial degrees to test efficiency\n        time.append([random.randint(-10, 10) for _ in range(n)])\n\n    # Generate Space Complexity Test Cases\n    for _ in range(25):\n        n = random.randint(20, 50)  # moderate sized polynomials, potentially creating large output\n        space.append([random.randint(1, 10) for _ in range(n)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/63": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    # Choosing some typical small values from the definition of the fibfib function\n    base.extend([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n    # Corner Cases\n    # Values that are on the boundaries of different computational paths\n    corner.append(0)  # minimum value for base computation\n    corner.append(1)  # also should return 0\n    corner.append(2)  # first non-zero\n    corner.append(3)  # first computed by recursive definition\n    corner.extend([11, 12, 15, 20])  # further values likely to be correct if smaller values are\n    \n    # Time Complexity Cases\n    # Challenging the time complexity with larger numbers\n    time.extend([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])\n\n    # Space Complexity Cases\n    # Using random large values to potentially challenge space (memory usage) during computation\n    space.extend(random.randint(900, 1000) for _ in range(25))\n\n    # Extending test cases to ensure at least 25 cases in each category\n    while len(base) < 25:\n        base.append(random.randint(5, 20))\n    while len(corner) < 25:\n        corner.append(random.randint(20, 50))\n    while len(time) < 25:\n        time.append(random.randint(500, 1500))\n    while len(space) < 25:\n        # Generating high values, though care must be taken to not reach memory limits\n        space.append(random.randint(1000, 2000))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/64": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append(\"\")  # Empty string\n    base.append(\"a\")  # Single vowel\n    base.append(\"b\")  # Single consonant\n    base.append(\"aeiou\")  # All lowercase vowels\n    base.append(\"AEIOU\")  # All uppercase vowels\n    base += [\"hello\", \"example\", \"programming\"]  # Common words with mixed vowels and consonants\n    \n    # Corner cases\n    corner.append(\"y\")  # 'y' not at the end\n    corner.append(\"syzygy\")  # 'y' at the end and middle\n    corner.append(\"Y\")  # Uppercase 'y' not at the end\n    corner.append(\"vacancyY\")  # Uppercase 'y' at the end\n    corner += [\"A\"*50, \"B\"*50]  # Long strings without/with only one vowel at end\n    \n    # Generating Time complexity cases\n    for _ in range(25):\n        length = random.randint(50, 100)  # Long strings\n        word = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n        time.append(word)\n\n    # Generating Space complexity cases\n    for _ in range(25):\n        length = random.randint(100, 200)  # Very long strings\n        word = ''.join(random.choice(string.ascii_letters) for _ in range(length))\n        space.append(word)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/65": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    for _ in range(25):\n        x = random.randint(1, 100000)  # Use moderate sized positive integers\n        shift = random.randint(0, 10)  # Typical shifts\n        base.append((x, shift))\n\n    # Corner Test Cases\n    corner.append((0, 0))  # Smallest values\n    corner.append((-1, 1))  # Negative integers\n    corner.append((12345, 5))  # Shift equal to length\n    corner.append((67890, 999))  # Oversized shift, very large compared to number of digits\n    for _ in range(21):\n        x = random.randint(-1000, 1000)  # Cover both negative and small positive values\n        shift = random.randint(0, 5)  # Small shifts\n        corner.append((x, shift))\n\n    # Time Complexity Test Cases (large inputs)\n    for _ in range(25):\n        x = random.randint(1, 10**18)  # Very large numbers\n        shift = random.randint(0, 1000)  # Large shifts\n        time.append((x, shift))\n\n    # Space Complexity Test Cases (intensive memory but not necessarily large numbers)\n    for _ in range(25):\n        x = random.randint(-10**18, 10**18)  # Very large negative and positive numbers\n        shift = random.randint(0, 100)  # Moderate to large shifts\n        space.append((x, shift))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/66": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: Simple cases with a mixture of characters\n    for _ in range(25):\n        length = random.randint(1, 20)  # Random length from 1 to 20\n        case = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))\n        base.append(case)\n\n    # Corner cases: Mostly focusing on boundary values and special characters\n    corner.append(\"\")  # Empty string case\n    corner.append(\"AB\" * 12)  # Exactly 24 uppercase characters\n    corner.append(\"ab\" * 12 + \"CD\")  # String ending with two uppercase characters\n    corner.append(\"#$%^\" * 6)  # Special characters only\n    corner.append(\"1234567890\" * 2)  # Digit string\n    for _ in range(20):\n        length = random.randint(1, 5)  # Smaller strings to focus on specific cases\n        case = ''.join(random.choice(string.ascii_uppercase) for _ in range(length))  # Uppercase only\n        corner.append(case)\n\n    # Time complexity cases: Larger strings to test performance\n    for _ in range(25):\n        length = random.randint(1000, 2000)\n        case = ''.join(random.choice(string.ascii_letters + string.digits + string.punctuation) for _ in range(length))\n        time.append(case)\n\n    # Space complexity cases: Focusing on specific patterns and large amounts of similar data\n    space.append(\"A\" * 1000)  # Large string of the same uppercase letter\n    space.append(\"z\" * 1000)  # Large string of the same lowercase letter\n    for _ in range(23):\n        length = random.randint(500, 1000)\n        case = ''.join(random.choice(string.ascii_uppercase) for _ in range(length))  # Large uppercase letters only\n        space.append(case)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/67": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Basic valid inputs\n    base.append((\"3 apples and 4 oranges\", 10))\n    base.append((\"0 apples and 1 oranges\", 6))\n    base.append((\"2 apples and 3 oranges\", 100))\n    base.append((\"100 apples and 1 oranges\", 120))\n    \n    # Corner Cases: Edge of the constraints\n    corner.append((\"0 apples and 0 oranges\", 5))\n    corner.append((\"1 apples and 0 oranges\", 1))\n    corner.append((\"0 apples and 1 oranges\", 2))\n    corner.append((\"500 apples and 400 oranges\", 1000))\n    \n    # Time Complexity Cases: Large numbers for stress testing\n    for i in range(25):\n        apples = random.randint(0, 100000)\n        oranges = random.randint(0, 100000)\n        total = apples + oranges + random.randint(0, 100000)\n        time.append((f\"{apples} apples and {oranges} oranges\", total))\n    \n    # Space Complexity Cases: Long strings to test memory usage\n    for i in range(25):\n        apples = random.randint(0, 10)\n        oranges = random.randint(0, 10)\n        total = apples + oranges + random.randint(0, 10)\n        padding = \" \" * (1000 * i)  # Padding with increasing length of spaces\n        space.append((f\"{apples} apples and {oranges} oranges{padding}\", total))\n    \n    # Additional cases to fulfill the requirement of at least 100 cases\n    while len(base) < 25:\n        apples = random.randint(0, 50)\n        oranges = random.randint(0, 50)\n        total = apples + oranges + random.randint(1, 50)\n        base.append((f\"{apples} apples and {oranges} oranges\", total))\n        \n    while len(corner) < 25:\n        apples = random.randint(0, 1) * 1000  # Corner case, large numbers on boundaries\n        oranges = random.randint(0, 1) * 1000\n        total = apples + oranges + random.randint(1, 1000)\n        corner.append((f\"{apples} apples and {oranges} oranges\", total))\n        \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/68": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[int]], List[List[int]], List[List[int]], List[List[int]]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base case scenarios\n    for _ in range(25):\n        n = random.randint(1, 20)  # small size for simplicity\n        arr = [random.randint(0, 100) for _ in range(n)]\n        base.append(arr)\n    \n    # Corner case scenarios\n    for _ in range(25):\n        # All even numbers\n        arr = [random.randint(0, 50) * 2 for _ in range(random.randint(1, 20))]\n        corner.append(arr)\n        \n        # All odd numbers\n        arr = [random.randint(0, 50) * 2 + 1 for _ in range(random.randint(1, 20))]\n        corner.append(arr)\n        \n        # Empty array\n        corner.append([])\n        \n        # Single even number\n        arr = [random.randint(0, 50) * 2]\n        corner.append(arr)\n\n    # Time complexity test scenarios\n    for _ in range(25):\n        n = 10000  # maximum size\n        arr = [random.randint(0, 10000) for _ in range(n)]\n        time.append(arr)\n\n    # Space complexity test scenarios\n    for _ in range(25):\n        # very sparse even numbers (most are odd)\n        arr = [random.randint(1, 100) * 2 if random.random() < 0.1 else random.randint(1, 100) * 2 + 1 for _ in range(1000)]\n        space.append(arr)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/69": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases - general scenarios to check normal behavior\n    base.append([1, 2, 2])\n    base.append([3, 3, 3, 3])\n    base.append([1])\n    base.append([5] * 5)  # 5 occurs 5 times\n    base.append([x for x in range(1, 10)])  # numbers 1 to 9\n\n    # Corner cases - edge and boundary cases\n    corner.append([1] * 1)  # Single element list\n    corner.append([2, 2])  # Smallest number repeat equal to the number itself\n    corner.append([1000] * 1000)  # A large number repeated many times\n    corner.append([1] + [2]*2 + [3]*3)  # Mixed frequencies\n    corner.append([999] * 999 + [1000])  # One max frequency near boundary\n\n    # Time complexity - large number of inputs to test performance\n    time.extend([random.randint(1, 50) for _ in range(10000)] for _ in range(25))\n\n    # Space complexity - large inputs to test memory usage\n    space.append([1] * 100000)\n    space.append([2, 2] + [3] * 1000 + [4] * 4000)\n    space.append([20] * 20 + [30] * 30 + [40] * 40)\n    space.extend([random.randint(1, 50) for _ in range(100000)] for _ in range(10))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/7": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.append(([], 'a'))  # Empty list of strings\n    base.append((['hello', 'world'], ''))  # Empty substring\n    base.append((['hello', 'world'], 'hello'))  # Substring is a full string from list\n    base.append((['abc', 'abcd', 'abcde'], 'abc'))  # Substring at the start of each string\n    \n    # Corner cases\n    corner.append((['a'*1000 for _ in range(10)], 'a'))  # Large strings of repeating characters\n    corner.append((['12345', '67890'], 'abc'))  # Substring not found\n    corner.append((['12345']*100, '12345'))  # Multiple occurrences of the same string\n    corner.append((['case', 'CASE', 'CaSe'], 'case'))  # Case sensitivity check\n\n    # Time complexity focused cases\n    time += [(list('a' * i for i in range(1, 1001)), 'a')]  # Gradual increase in string length\n\n    # Space complexity focused cases\n    for i in range(25):\n        space.append((['megastring']*i, 'mega'))  # Increasing the number of identical string entries\n\n    # Extended Base Cases\n    for i in range(10):\n        base.append(([str(j) for j in range(1000)], str(i)))  # Numeric strings\n\n    # Extended Corner Cases\n    for i in range(10):\n        corner.append((['', ' ' * 100, '\\t\\n']*10, str(i)))  # Strings of different whitespaces\n\n    # Additional Time Complexity Cases\n    for i in range(25):\n        time.append((['x'*1000]*100, 'x'*i))  # Large number of large strings with varying substring lengths\n\n    # Additional Space Complexity Cases\n    for i in range(25):\n        space.append((['alpha', 'beta', 'gamma']*1000, 'a'*i))  # Fixed number of string types, varying substring sizes\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/70": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    base.append([])  # Empty list\n    base.append([1])  # Single element\n    base.append([2, 1])  # Two elements, needs sorting\n    base.append([3, 3, 3])  # All elements the same, trivial case but with more elements\n\n    # Generating additional simple base cases\n    for _ in range(21):\n        base.append(sorted([random.randint(1, 100) for _ in range(5)]))\n\n    # Corner Cases\n    corner.append([random.randint(-10**6, 10**6) for _ in range(1)])  # Single large range element\n    corner.append([random.randint(-10**6, 10**6), random.randint(-10**6, 10**6)])  # Two large range elements\n    corner.append([5, -5, 5, -5, 5, -5, 5, -5])  # Alternating pattern large number of times\n    corner.append([-1 * i for i in range(100, 0, -1)])  # Large negative numbers monotonically decreasing\n\n    # Generating additional corner cases\n    for _ in range(21):\n        len_list = random.randint(5, 10)\n        corner.append([random.choice([-10**6, 10**6]) for _ in range(len_list)])\n\n    # Time Complexity Cases\n    for i in range(25):\n        time.append(sorted([random.randint(-10**5, 10**5) for _ in range(1000)]))  # Sorted large lists\n\n    # Space Complexity Cases\n    for i in range(25):\n        space.append(sorted([random.randint(-10, 10) for _ in range(1000)]))  # Sorted medium range large lists\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/71": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases: Regular valid triangles\n    for i in range(25):\n        a = random.randint(1, 100)\n        b = random.randint(1, 100)\n        c = random.randint(1, 100)\n        if a + b > c and a + c > b and b + c > a:\n            base.append((a, b, c))\n\n    # Corner Cases: Include edge cases like extremely small or large values or almost degenerate triangles\n    corner.append((1, 1, 1))  # Minimal Valid triangle\n    corner.append((1, 1, 2))  # Invalid triangle, sum fails by 1\n    corner.append((999, 999, 999))  # Large valid equilateral triangle\n    corner.append((1000, 1, 1))  # Large invalid triangle\n    for i in range(21):\n        a = random.randint(1, 10)\n        b = random.randint(1, 10)\n        c = a + b - 1  # just one less than needed to be valid\n        corner.append((a, b, c))\n\n    # Time Complexity Test Cases: Large set of valid triangles to test efficiency\n    for i in range(25):\n        a = random.randint(100, 1000)\n        b = random.randint(100, 1000)\n        c = a + b - random.randint(1, 20)\n        time.append((a, b, c))\n\n    # Space Complexity Test Cases: Ensure the system can handle the maximum expected input size\n    for i in range(25):\n        a = random.randint(1, 500)\n        b = random.randint(1, 500)\n        c = a + b - random.randint(1, 10)\n        space.append((a, b, c))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/72": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        length = random.randint(1, 10)  # Length between 1 and 10 for simplicity\n        lst = [random.randint(0, 10) for _ in range(length)]\n        max_weight = random.randint(0, 2 * sum(lst))  # Reasonable weights\n        base.append((lst, max_weight))\n    \n    # Corner test cases\n    # Empty list, minimal and maximal w\n    corner.append(([], 0))\n    corner.append(([], 100))\n    # Single element list\n    corner.append(([1], 1))\n    corner.append(([1], 0))\n    corner.extend([([random.randint(0, 10)], random.randint(0, 10)) for _ in range(21)])\n    \n    # Time complexity-oriented test cases\n    for _ in range(25):\n        length = random.randint(1000, 2000)  # Large lists\n        lst = [random.randint(0, 100) for _ in range(length)]\n        max_weight = random.randint(0, 2 * sum(lst))\n        time.append((lst, max_weight))\n    \n    # Space complexity-oriented test cases\n    for _ in range(25):\n        length = random.randint(500, 1000)  # Moderately large lists\n        lst = [random.randint(0, 100) for _ in range(length)]\n        max_weight = random.randint(0, 2 * sum(lst))\n        space.append((lst, max_weight))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/73": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    # Regular arrays of varying lengths where changes are known to be simple\n    base.extend([\n        list(range(10)),  # No need to change for palindrome\n        list(range(5)) + list(range(4, -1, -1)),  # Palindrome already\n        [1, 2, 2, 1],  # No changes needed\n        [5, 3, 3, 5],  # No changes needed\n        [1, 2, 3, 4, 5, 6] + [6, 5, 4, 3, 2, 1]  # Palindrome already\n    ])\n\n    # Corner Test Cases\n    # Smallest arrays, potential boundary values and single-element variations\n    corner.extend([\n        [],  # Empty array, should be palindrome\n        [1],  # Single element, palindrome\n        [1, 1],  # Two same elements, palindrome\n        [1, 2],  # Two different elements, 1 change needed\n        [1, 2, 1, 2, 1],  # Odd numbered array, small change\n        [1, 3, 1, 3, 1, 4]  # Small array with an outlier\n    ])\n\n    # Time Complexity Focused Test Cases\n    # Very large arrays to check how the function performs under stress\n    for i in range(25):\n        # Create large arrays with slight modifications to be non-palindrome\n        size = 950  # Just below the limit\n        half = list(range(size // 2))\n        time.append(half + half[::-1] + [1000])  # Just one change needed at the end\n\n    # Space Complexity Focused Test Cases\n    # Arrays to check memory usage perhaps due to length or specific structure\n    for i in range(25):\n        # Create palindrome arrays of maximum allowed size\n        half = list(range(500))\n        space.append(half + half[::-1])  # No changes needed, full palindrome\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/74": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Helper function to generate a random string\n    def random_string(max_length=1000):\n        length = random.randint(1, max_length)\n        return ''.join(random.choice(string.ascii_letters) for _ in range(length))\n\n    # Generate base cases\n    for _ in range(25):\n        lst1 = [random_string() for _ in range(random.randint(1, 10))]\n        lst2 = [random_string() for _ in range(random.randint(1, 10))]\n        base.append((lst1, lst2))\n\n    # Generate corner cases\n    # Edge cases with empty lists or strings\n    corner.append(([], []))\n    corner.append(([], [random_string() for _ in range(10)]))\n    corner.append(([random_string() for _ in range(10)], []))\n    corner.append(([], [random_string(1) for _ in range(1000)]))  # maximal number of minimal length strings in one list\n    corner.append(([random_string(1000) for _ in range(1000)], []))  # maximal number of maximal length strings in one list\n\n    # Generate time complexity cases\n    # Large number of strings in both lists\n    for _ in range(25):\n        lst1 = [random_string(50) for _ in range(1000)]  # moderate length, maximal count\n        lst2 = [random_string(50) for _ in range(1000)]\n        time.append((lst1, lst2))\n\n    # Generate space complexity cases\n    # Strings close to maximum allowable length\n    for _ in range(25):\n        lst1 = [random_string(1000) for _ in range(10)]  # maximal length, moderate count\n        lst2 = [random_string(1000) for _ in range(10)]\n        space.append((lst1, lst2))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/75": [
        "# Import statements\nfrom typing import Tuple, List, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    # Using small prime multiplications, ensuring they are below 100.\n    base.extend([2*3*5, 2*3*7, 2*5*7, 3*5*7, 3*5*11])\n\n    # Corner Test Cases\n    # Testing edge input values and special cases\n    corner.extend([1, 97, 2, 3, 5, 2*2*5]) # 97 is prime, 1 is less than the smallest prime\n\n    # Time Complexity Test Cases\n    # Challenging inputs for time complexity (though all inputs are < 100)\n    for x in range(2, 100):\n        if x in [2*3*5, 30, 2*7*11, 2*3*7, 2*5*13, 2*3*17, 3*5*7]:\n            continue\n        time.append(x)\n\n    # Space Complexity Test Cases\n    # Challenging inputs for space complexity (using primes and near-100 inputs)\n    prime_candidates = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    from itertools import combinations\n    for comb in combinations(prime_candidates, 3):\n        product = comb[0] * comb[1] * comb[2]\n        if product < 100:\n            space.append(product)\n\n    # Reducing lists to the first 25 elements each to keep it manageable\n    base = base[:25]\n    corner = corner[:25]\n    time = time[:25]\n    space = space[:25]\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/76": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Cases\n    for i in range(25):\n        n = random.randint(2, 10)  # Small positive bases (2 to 10)\n        p = random.randint(2, 6)   # Powers (2 to 6)\n        x = n ** p\n        base.append((x, n))\n    \n    # Corner Cases\n    corner.append((1, 4))        # Any power of 1 is always 1\n    corner.append((2, 2))\n    corner.append((8, 2))\n    corner.append((3, 2))        # 3 is not a power of 2\n    corner.append((0, 0))        # 0 to any power except 0 is 0\n    corner.append((0, 1))\n    corner.append((-1, -1))      # -1 to the power of -1 is -1\n    corner.append((-1, 1))\n    corner.append((1, 0))        # Special checks for power 0 which should always be False\n    while len(corner) < 25:\n        n = random.randint(-10, 10)  # Include more negatives and zero\n        p = random.randint(1, 5)     # Reasonable positive powers\n        x = n ** p\n        if (x, n) not in corner:\n            corner.append((x, n))\n        \n    # Time Complexity Cases\n    for i in range(25):\n        n = random.randint(2, 20)  # Larger range of bases\n        p = random.randint(50, 100)  # High powers to push the loop longer in the function\n        x = n ** p\n        time.append((x, n))\n    \n    # Space Complexity Cases\n    for i in range(25):\n        n = random.randint(-20, 20)  # Negative and positive bases\n        p = random.randint(10, 15)   # High but not as high as time complexity to maintain space\n        x = n ** p\n        space.append((x, n))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/77": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases:\n    # These include an obvious small range of cubes and non-cubes\n    base.extend([0, 1, 8, 27, 64, 125, -1, -8, -27, -64, -125, 2, 3, 5, 10, -2, -3, -10, 50, -50])\n    while len(base) < 25:\n        n = random.randint(-100, 100)\n        base.append(n**3)\n        base.append(n**3 + 1)\n        base.append(n**3 - 1)\n    \n    # Corner Cases:\n    # Tests around the valid boundaries and minimal increments\n    for n in [-100, -10, 0, 10, 100]:\n        corner.append(n**3)\n        if n != 0:\n            corner.append(n**3 + 1)\n            corner.append(n**3 - 1)\n    \n    # Time Complexity Cases:\n    # Generating large numbers to test the efficiency of the function regarding time\n    for _ in range(25):\n        n = random.randint(1, 10**6)\n        time.append(n**3)\n    \n    # Space Complexity Cases:\n    # Using large negative numbers to test the function behavior on negative inputs\n    for _ in range(25):\n        n = random.randint(-10**6, -1)\n        space.append(n**3)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/78": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases\n    base.append(\"AB\")  # Expected: 1, Contains prime 'B'\n    base.append(\"1077E\")  # Expected: 2, Contains prime '7' twice\n    base.append(\"123456789ABCDEF0\")  # Expected: 6, Contains multiples primes\n    base.append(\"2020\")  # Expected: 2, Contains prime '2' twice\n    base.append(\"\")  # Expected: 0, Empty string\n    for _ in range(20):\n        base.append(\"D\" * _)  # Test increasing counts of 'D'\n\n    # Corner cases\n    corner.append(\"F\" * 25)  # Expected: 0, All 'F', no primes\n    corner.append(\"2\" * 50)  # Expected: 50, All '2', all primes\n    corner.append(\"7B3D2357\")  # Expected: 8, All prime digits\n    corner.append(\"A0CDEF\")  # Expected: 0, Contains no prime digits\n    corner.append(\"FFFFFFFFFF\")  # No prime digits in large string\n    for _ in range(20):\n        corner.append(\"D\" * (100 - _))  # Decreasing counts of 'D'\n\n    # Time complexity cases\n    for _ in range(25):\n        time.append(\"2357BD\" * (100 + _ * 10))  # Large input strings with only prime digits\n    \n    # Space complexity cases\n    for i in range(25):\n        mix = \"2357BD\" * i + \"89A0CF\" * (25 - i)  # Mixed prime and non-prime large inputs\n        space.append(mix)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/79": [
        "# Import statements\nfrom typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base case examples\n    for i in range(25):\n        base.append(i)  # Simple base cases starting from 0 to 24\n    \n    # Corner case examples\n    for i in range(25):\n        if i == 0:\n            corner.append(0)  # Edge case for the smallest positive integer\n        else:\n            corner.append(2**i - 1)  # Cases like 1, 3, 7, 15, ..., indicating all bits as 1\n    \n    # Time complexity examples (Testing for larger inputs)\n    for i in range(25, 125):\n        time.append(i * 1000)  # Larger numbers to test the time complexity\n    \n    # Space complexity examples (Testing for very large inputs)\n    for i in range(25):\n        space.append(2**30 + i)  # Very large numbers to test the limits of the space complexity\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/8": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Case\n    # Baseline simple inputs\n    for _ in range(25):\n        n = random.randint(1, 10)\n        base.append([random.randint(-100, 100) for _ in range(n)])\n\n    # Corner Cases\n    # Edge cases such as empty list and lists with one element, maximum and minimum int value, zero\n    corner.append([])  # Empty list\n    for _ in range(12):  # Evenly distribute other types\n        corner.append([random.randint(-100, 100)])  # Single element list\n    corner.append([0]*random.randint(1, 10))  # List of zeros\n    corner.append([int(1e9)]*random.randint(1, 5))  # List of large positive numbers\n    corner.append([int(-1e9)]*random.randint(1, 5))  # List of large negative numbers\n    \n    # Time-critical Cases\n    # Very large lists for testing execution time\n    for _ in range(25):\n        n = random.randint(10000, 100000)\n        time.append([random.randint(-1000, 1000) for _ in range(n)])\n\n    # Space-critical Cases\n    # Heavy on numbers and/or large lists with meaningful values like boundaries of large numbers\n    for _ in range(25):\n        n = random.randint(1000, 5000)\n        space.append([random.randint(int(-1e6), int(1e6)) for _ in range(n)])\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/80": [
        "# Import statements\nfrom typing import List, Tuple\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[str], List[str], List[str], List[str]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        length = random.randint(3, 10)  # Length from 3 to 10\n        s = ''.join(random.choices(string.ascii_letters, k=length))\n        base.append(s)\n\n    # Corner cases\n    corner.append(\"abc\")  # exactly 3 characters, all distinct\n    corner.append(\"aba\")  # exactly 3, last two are the same\n    corner.append(\"aaa\")  # all characters same\n    while len(corner) < 25:\n        length = random.randint(1, 3)  # Length from 1 to 3 to test minimum edge cases\n        s = ''.join(random.choices(string.ascii_letters, k=length))\n        corner.append(s)\n\n    # Time complexity cases\n    for _ in range(25):\n        length = random.randint(100, 500)  # Large lengths to test efficiency\n        s = ''.join(random.choices(string.ascii_letters, k=length))\n        time.append(s)\n\n    # Space complexity cases\n    for _ in range(25):\n        length = random.randint(50, 100)  # Moderate lengths to test moderate resources usage\n        s = ''.join(random.choices(string.ascii_letters, k=length))\n        space.append(s)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/81": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[List[float]], List[List[float]], List[List[float]], List[List[float]]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    # Common scenarios\n    base.append([4.0, 3.7, 3.3, 3.0, 2.7, 2.3, 2.0, 1.7, 1.3, 1.0, 0.7, 0.0])  # exactly one of each possible grade\n    base.append([2.0] * 5)  # repetitive common grades\n    base.append([0.5, 3.8, 3.1, 2.5, 1.2, 3.9, 3.5])  # random common grades\n    base.append([4.0] * 25)  # pure high A+ grades\n    for i in range(21):\n        base.append([random.uniform(0.0, 4.0) for _ in range(10)])  # random GPAs\n\n    # Corner cases\n    # Boundary conditions\n    corner.append([4.0])  # highest grade\n    corner.append([0.0])  # lowest grade\n    corner.append([3.71, 3.69])  # just above and below the A grade cutoff\n    corner.append([2.01, 1.99])  # just above and below the C+ grade cutoff\n    corner.append([0.01, 3.99])  # very close to boundaries within E and A+\n    for i in range(20):\n        corner.append([random.choice([0.0, 4.0, 2.0, 1.0, 3.5]) for _ in range(5)])  # critical boundary values\n\n    # Time complexity cases\n    # Test cases with very large inputs\n    for i in range(25):\n        time.append([random.uniform(0.0, 4.0) for _ in range(1000)])  # large number of GPAs\n\n    # Space complexity cases\n    # Edge cases focusing on minimal and precise floating point\n    space.append([4.0, 3.8, 3.4, 3.1, 2.8, 2.4, 2.1, 1.8, 1.4, 1.1, 0.8, 0.1])\n    for i in range(24):\n        space.append([round(random.uniform(0.0, 4.0), 1) for _ in range(50)])  # precise to 1 decimal point GPAs\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/82": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base test cases\n    for _ in range(25):\n        # Create strings of random length with guaranteed prime lengths between 2 and 100\n        prime_lengths = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n        length = random.choice(prime_lengths)\n        base.append(''.join(random.choices(string.ascii_letters + string.digits, k=length)))\n\n    # Corner test cases\n    # Creating strings with lengths of 1 (not prime) and some known non-prime lengths\n    non_prime_lengths = [1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]\n    # Ensure we generate at least one test case for each of these\n    for length in non_prime_lengths[:25]:\n        corner.append(''.join(random.choices(string.ascii_letters + string.digits, k=length)))\n\n    # Time complexity test cases\n    for i in range(25):\n        # Creating very long strings of random lengths close to the upper limit (around 1,000,000 characters)\n        # Additionally, making sure the length at the upper boundary might also be prime\n        length = 10**6 - 2 + i  # As 10^6 itself could be too large, slightly adjust it around the limit\n        time.append(''.join(random.choices(string.ascii_letters + string.digits, k=length)))\n\n    # Space complexity test cases\n    for _ in range(25):\n        # Similar to time complexity but focus on having prime lengths and potentially some very lengthy sequences\n        length = random.choice([999983, 999979])  # Large prime numbers close to 10^6\n        space.append(''.join(random.choices(string.ascii_letters + string.digits, k=length)))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/83": [
        "# Import statements\nfrom typing import Tuple, List, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    base.extend([1, 2, 3, 4, 5, 10])  # typical low values but within valid range\n\n    # Corner cases\n    corner.append(1)  # Smallest possible N (n=1)\n    for i in range(19, 26):  # High but small numbers to check edge behaviors\n        corner.append(i)\n\n    # Time complexity cases\n    time.extend([100, 200, 300, 400, 500, 600, 700, 800, 900, 1000])  # Large numbers to test performance\n\n    # Space complexity cases\n    for i in range(25):  # large numbers close to each other to test space handling\n        space.append(100 + i)\n\n    # Add more cases to reach at least 100 challenging inputs altogether\n    # Fill the rest of the test cases ensuring at least 25 per type\n    while len(base) < 25:\n        base.append(len(base) + 2)  # simple increment\n    while len(corner) < 25:\n        corner.append(1000 + len(corner))\n    while len(time) < 25:\n        time.append(1100 + 10 * len(time))\n    while len(space) < 25:\n        space.append(500 + 5 * len(space))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/84": [
        "from typing import List, Tuple, Any\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases: easily verifiable and typical examples\n    for i in range(1, 26):\n        base.append(i)\n\n    # Corner cases: boundary values and extremes\n    corner.append(0)  # Minimum value\n    corner.append(10000)  # Maximum value\n    corner.extend([1, 2, 9999, 9998])  # Near bounds\n    for i in range(20):\n        corner.append(i)  # First few numbers\n\n    # Time complexity cases: to test performance in nearly worst cases\n    for i in range(50):\n        time.append(9000 + i)  # Values close to upper boundary\n\n    # Space complexity cases: to test performance with various digit sums\n    space.append(1234)  # Random typical number\n    space.append(9999)  # Large number with high digit sum\n    for i in range(23):\n        space.append(1000 + i * 100)  # Even distribution in the range\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/85": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        n = random.randint(1, 10)  # Small size for base cases\n        lst = [random.randint(-100, 100) for _ in range(n)]\n        base.append(lst)\n\n    # Corner cases\n    for _ in range(25):\n        # Single element list\n        single_element = [random.randint(-100, 100)]\n        corner.append(single_element)\n        \n        # All elements are even, with an odd length\n        odd_length = random.randint(1, 5) * 2 + 1\n        all_even = [random.randint(-100, 100) * 2 for _ in range(odd_length)]\n        corner.append(all_even)\n        \n        # All elements are odd, with an odd length\n        all_odd = [random.randint(-50, 50) * 2 + 1 for _ in range(odd_length)]\n        corner.append(all_odd)\n        \n        # Zeroes in odd indices\n        list_with_zeroes = [random.randint(-100, 100) if i % 2 == 0 else 0 for i in range(odd_length)]\n        corner.append(list_with_zeroes)\n\n    # Time complexity cases\n    for _ in range(25):\n        large_size = random.randint(1000, 2000)  # Large size for time complexity\n        large_list = [random.randint(-1000, 1000) for _ in range(large_size)]\n        time.append(large_list)\n\n    # Space complexity cases\n    for _ in range(25):\n        moderate_size = random.randint(100, 200)  # Moderate size for space complexity\n        moderate_list = [random.randint(-100, 100) for _ in range(moderate_size)]\n        space.append(moderate_list)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/86": [
        "# Import statements\nfrom typing import List, Any, Tuple\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate Base Cases\n    base.append('Hello World')  # typical input\n    base.append('anti shuffle this string')  # standard sentence with multiple words\n    base.append('123 456 789')  # numbers as strings\n    base.append('AaBbCc')  # mixed case single word\n    base.append('!!! $$$ ???')  # punctuation only\n    \n    # Generate Corner Cases\n    corner.append(' ')  # just space\n    corner.append('a')  # single character\n    corner.append('a ' * 500) # repeated character with space\n    corner.append(string.punctuation * 100)  # long string of punctuations\n    corner.append(''.join(chr(i) for i in range(32, 127)) * 8)  # string of all ASCII printable characters repeated\n\n    # Generate Time Complexity Cases\n    alphabet = string.ascii_letters + string.digits + string.punctuation + ' '\n    for _ in range(25):\n        long_str = ''.join(random.choice(alphabet) for _ in range(1000))  # max length strings\n        time.append(long_str)\n    \n    # Generate Space Complexity Cases\n    # Construct strings of increasing lengths to test space handling.\n    space_lengths = [random.randint(1, 1000) for _ in range(25)]\n    for length in space_lengths:\n        space.append(''.join(random.choice(alphabet) for _ in range(length)))\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/87": [
        "# Import statements\nfrom typing import List, Any, Tuple\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    import random\n\n    base, corner, time, space = [], [], [], []\n\n    # Base Case Test Cases\n    for _ in range(25):\n        rows = random.randint(1, 5)  # small matrices\n        lst = [[random.randint(1, 5) for _ in range(random.randint(1, 5))] for _ in range(rows)]\n        x = random.randint(1, 5)\n        base.append((lst, x))\n\n    # Corner Case Test Cases\n    # Include cases with 0 rows, single element lists, lists without the target, and large numbers\n    corner.append(([], 1))  # empty list\n    corner.append(([[1]], 1))  # smallest possible non-empty list\n    for _ in range(3, 25):\n        rows = 1 if _ % 2 == 0 else 0  # alternating between 0 and 1 rows\n        lst = [[random.randint(2, 5) for _ in range(random.randint(1, 5))]] if rows else []\n        x = 1  # not present in the list\n        corner.append((lst, x))\n\n    # Time Complexity Test Cases\n    # Very large lists designed to test the limits of the algorithm\u2019s time complexity\n    for _ in range(25):\n        rows = random.randint(50, 100)\n        lst = [[random.randint(1, 5) for _ in range(random.randint(50, 100))] for _ in range(rows)]\n        x = random.randint(1, 5)\n        time.append((lst, x))\n\n    # Space Complexity Test Cases\n    # Very deep or very wide matrices\n    for _ in range(25):\n        rows = random.randint(10, 20)\n        width = random.randint(100, 200)  # wide matrices\n        lst = [[random.randint(1, 5) for _ in range(width)] for _ in range(rows)]\n        x = random.randint(1, 5)\n        space.append((lst, x))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/88": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases\n    for _ in range(25):\n        array_length = random.randint(1, 100)  # Reasonable small array size\n        array = [random.randint(0, 100) for _ in range(array_length)]\n        base.append(array)\n\n    # Corner Test Cases\n    # Case 1: Empty list\n    corner.append([])\n    # Case 2: Single element list\n    corner.append([random.randint(0, 100)])\n    # Case 3: Two elements causing reverse (even sum)\n    corner.append([2, 2])\n    # Case 4: Two elements causing no reverse (odd sum)\n    corner.append([1, 2])\n    # Add more edge cases to reach at least 25 corner cases\n    while len(corner) < 25:\n        # Generate list with boundary elements to test constraint handling\n        length = random.randint(1, 100)\n        array = [random.choice([0, 100]) for _ in range(length)]\n        corner.append(array)\n\n    # Time Test Cases\n    for _ in range(25):\n        array_length = random.randint(500, 1000)  # Larger sizes for performance testing\n        array = [random.randint(0, 1000) for _ in range(array_length)]\n        time.append(array)\n\n    # Space Test Cases\n    for _ in range(25):\n        # Create arrays with large numbers for memory usage testing\n        array_length = random.randint(100, 200)\n        array = [random.randint(0, 10000) for _ in range(array_length)]\n        space.append(array)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/89": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport string\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base cases\n    for _ in range(25):\n        # Generating strings of random length from 1 to 10 characters\n        length = random.randint(1, 10)\n        base_case = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        base.append(base_case)\n\n    # Corner cases\n    corner.append(\"\")  # Smallest input, an empty string\n    corner.append(string.ascii_lowercase)  # Entire alphabet\n    corner.append(\"a\"*100)  # Repeated character, edge of typical handling\n    corner.append(\"z\"*100)  # Repeated character edge case, all z's\n\n    # To complete 25 corner cases\n    for i in range(21):\n        length = random.randint(50, 100)  # Large length string, challenging for handling\n        corner_case = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        corner.append(corner_case)\n\n    # Time complexity cases (focus on large inputs)\n    for _ in range(25):\n        length = random.randint(1000, 5000)  # Very long strings to test performance\n        time_case = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        time.append(time_case)\n\n    # Space complexity cases (focus on length and memory)\n    for _ in range(25):\n        length = random.randint(500, 1000)  # Long strings to test memory usage\n        space_case = ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        space.append(space_case)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/9": [
        "# Import statements\nfrom typing import List, Tuple, Any\nfrom random import randint, shuffle\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for _ in range(25):\n        n = randint(5, 15)  # Choose a moderate size for the list\n        base.append([randint(-100, 100) for __ in range(n)])\n    \n    # Corner Cases\n    # Adding cases like an empty list and a list with varied integer ranges\n    corner.append([])  # Empty list\n    corner.append([randint(-100000, 100000) for _ in range(10)])  # Large numbers\n    corner.append([0] * 10)  # All zeros\n    corner.append([1] * 10)  # All ones with 10 elements\n\n    # Time Complexity Cases\n    # Larger lists to test the time complexity\n    for _ in range(25):\n        large_size = randint(900, 1000)  # Near upper limit of allowed range\n        time.append([randint(-1000, 1000) for __ in range(large_size)])\n\n    # Space Complexity Cases\n    # Lists with varied lengths to test memory usage\n    for _ in range(25):\n        varied_size = randint(500, 1000)  # Varied large sizes\n        space.append([randint(-100, 100) for __ in range(varied_size)])\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/90": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base cases\n    for _ in range(25):\n        # Lists of varying lengths up to 10, with unique elements\n        n = random.randint(2, 10)\n        lst = random.sample(range(1, 100), n)\n        base.append(lst)\n    \n    # Generate corner cases\n    for _ in range(25):\n        # Special corner cases including duplicate elements, or exactly two elements\n        r = random.choice([0, 2])\n        if r == 0:\n            # Generate list with exactly two elements, which are unique\n            corner.append(random.sample(range(1, 100), 2))\n        elif r == 2:\n            # Generate list with two distinct elements and duplicates\n            val1, val2 = random.sample(range(1, 100), 2)\n            lst = [val1] * random.randint(1, 5) + [val2] * random.randint(1, 5)\n            random.shuffle(lst)\n            corner.append(lst)\n        \n    # Generate time cases\n    for _ in range(25):\n        # Large lists up to 10000 elements to test efficiency\n        n = random.randint(9000, 10000)\n        lst = random.sample(range(-10000, 10000), n)\n        time.append(lst)\n    \n    # Generate space cases\n    for _ in range(25):\n        # Large or complex structure inputs\n        n = random.randint(9000, 10000)\n        lst = random.sample(range(-10000, 10000), n)\n        random.shuffle(lst)  # Ensure random distribution of elements\n        space.append(lst)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/91": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base Test Cases: Normal strings with varied sentences\n    for _ in range(25):\n        num_sentences = random.randint(1, 10)  # Random number of sentences\n        sentences = []\n        for _ in range(num_sentences):\n            sentences.append(\"I \" + \"am bored\" if random.random() < 0.5 else \"Something else\")\n        shuffle_ops = [\". \", \"? \", \"! \"]\n        base.append(\" \".join(sentence + random.choice(shuffle_ops) for sentence in sentences))\n    \n    # Corner Test Cases: Edge cases\n    corner.append(\"I am bored.\")  # Exactly one sentence starting with \"I\"\n    corner.append(\"i am bored!\")  # Sentence starting with lowercase 'i'\n    corner.append(\" \")  # Mostly whitespace\n    corner.append(\"!Something. ?Elsewhere. I am here.\")  # Mixed punctuation\n    while len(corner) < 25:\n        # Generate more random corner cases with complex punctuation mixes and case issues\n        sentence_count = random.randint(1, 3)\n        sentences = [\"i\" + \"am bored\" if random.random() < 0.3 else \"Something else\" for _ in range(sentence_count)]\n        corner.append(\" \".join(sentences) + random.choice([\".\", \"?\", \"!\"]))\n    \n    # Time Test Cases: Maximum length strings\n    for _ in range(25):\n        # Generate long strings close to 1000 characters\n        long_sentence = \"\"\n        for _ in range(1000):\n            long_sentence += random.choice(string.ascii_letters)\n        long_sentence = long_sentence[:998] + random.choice([\".\", \"!\", \"?\"])\n        time.append(long_sentence)\n    \n    # Space Test Cases: Large number of sentences\n    for _ in range(25):\n        many_sentences = \"\"\n        for _ in range(100):\n            many_sentences += \"\".join(random.choices(string.ascii_letters, k=random.randint(1, 10)))\n            separator = random.choice([\". \", \"! \", \"? \"])\n            many_sentences += separator\n        space.append(separator.join(many_sentences))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/92": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generate base test cases\n    for _ in range(25):\n        x = random.randint(-1000, 1000)\n        y = random.randint(-1000, 1000)\n        z = x + y\n        base.append((x, y, z))\n\n    # Generate corner test cases\n    for _ in range(25):\n        # Single large number scenarios\n        x = random.choice([random.randint(-1e9, -1e8), random.randint(1e8, 1e9)])\n        y = random.randint(-100, 100)\n        z = x + y\n        corner.append((x, y, z))\n\n        # Zero scenarios\n        x = 0\n        y = random.randint(-100, 100)\n        z = y\n        corner.append((x, y, z))\n\n        # Negative results in sum\n        x = random.randint(-500, -1)\n        y = random.randint(-500, -1)\n        z = x + y \n        corner.append((x, y, z))\n\n    # Reduce corner list to 25 cases exactly after adding several\n    corner = corner[:25]\n\n    # Generate time complexity test cases\n    for _ in range(25):\n        x = random.randint(1, 100)\n        y = random.randint(1, 100)\n        z = random.randint(1, 100)\n        time.append((x, y, z))\n\n    # Generate space complexity test cases\n    for _ in range(25):\n        # Using larger integers to test memory handling\n        x = random.randint(-1e6, 1e6)\n        y = random.randint(-1e6, 1e6)\n        z = random.randint(-1e6, 1e6)\n        space.append((x, y, z))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/93": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Test Cases (Normal and expected usage)\n    for _ in range(25):\n        base_message = ''.join(random.choices(string.ascii_letters + ' ', k=random.randint(5, 10)))\n        base.append(base_message.strip())\n\n    # Corner Test Cases (Edge cases that might reveal bugs)\n    # - Short strings\n    corner.append('a')\n    corner.append('Z')\n    # - All uppercase and all lowercase\n    corner.append('HELLO')\n    corner.append('world')\n    # - Strings where vowels are at edge of ASCII range\n    corner.append('Amen')\n    corner.append('zoo')\n    for _ in range(19):\n        corner_message = ''.join(random.choices(string.ascii_letters, k=random.randint(1, 3)))\n        corner.append(corner_message)\n        \n    # Time Complexity Test Cases (Large inputs to test efficiency)\n    for _ in range(25):\n        large_message = ''.join(random.choices(string.ascii_letters + ' ', k=random.randint(1000, 5000)))\n        time.append(large_message.strip())\n\n    # Space Complexity Test Cases (Optimized size to stress memory usage)\n    for _ in range(25):\n        space_message = ''.join(random.choices(string.ascii_letters + ' ', k=random.randint(500, 1000)))\n        space.append(space_message.strip())\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/94": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Generating base test cases\n    for _ in range(25):\n        size = random.randint(5, 15)  # Moderate size\n        lst = [random.randint(0, 100) for _ in range(size)]\n        base.append(lst)\n\n    # Generating corner test cases\n    corner_cases = [\n        [],  # Empty list\n        [0],  # Single value, zero\n        [1],  # Single value, one\n        [2],  # Lowest prime\n        [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]  # First ten primes\n    ]\n    for i in range(20):\n        size = random.randint(10, 15)\n        # High prime numbers\n        high_primes = [101, 103, 107, 109, 113, 127, 131, 137, 139, 149]\n        lst = [random.choice(high_primes) for _ in range(size)]\n        corner.append(lst)\n    corner += corner_cases[:min(len(corner_cases), 25 - len(corner))]\n    \n    # Generating time test cases (large inputs)\n    for _ in range(25):\n        size = random.randint(1000, 5000)  # Large size to challenge time efficiency\n        lst = [random.randint(0, 10000) for _ in range(size)]\n        time.append(lst)\n\n    # Generating space test cases (large individual numbers)\n    for _ in range(25):\n        size = random.randint(5, 20)\n        # Generate lists with few very large numbers\n        lst = [random.randint(10000, 1000000) if random.random() < 0.2 else random.randint(0, 100) for _ in range(size)]\n        space.append(lst)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/95": [
        "# Import statements\nfrom typing import Tuple, List, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for i in range(25):\n        # Randomly decide to generate all-lower or all-upper case keys\n        case_type = random.choice([string.ascii_lowercase, string.ascii_uppercase])\n        dictionary = {random.choice(case_type): random.randint(1, 100) for _ in range(5)}\n        base.append(dictionary)\n    \n    # Corner Cases\n    # Including cases with both lower and upper cases together, non-string keys and very minimal entries\n    for i in range(25):\n        if i % 2 == 0:\n            # Mixed case dictionaries\n            dict_lower = {random.choice(string.ascii_lowercase): random.randint(1, 100) for _ in range(3)}\n            dict_upper = {random.choice(string.ascii_uppercase): random.randint(1, 100) for _ in range(3)}\n            dict_lower.update(dict_upper)\n            corner.append(dict_lower)\n        else:\n            # Dictionaries with non-string keys intentionally\n            dictionary = {random.choice(string.ascii_lowercase): random.randint(1, 100) for _ in range(4)}\n            dictionary[random.randint(1, 100)] = random.choice(string.ascii_letters)\n            corner.append(dictionary)\n\n    # Time Complexity Cases\n    # Large dictionaries to test the performance in best and worst cases\n    for i in range(25):\n        size = 100 if i % 2 == 0 else 500  # alternating sizes to have variety\n        case_type = random.choice([string.ascii_lowercase, string.ascii_uppercase])\n        dictionary = {random.choice(case_type) + str(i): random.randint(1, 100) for i in range(size)}\n        time.append(dictionary)\n\n    # Space Complexity Cases\n    # Large uniform dictionaries with either all lower or all upper cases\n    for i in range(25):\n        size = 200 if i % 2 == 0 else 400\n        case_type = random.choice([string.ascii_lowercase, string.ascii_uppercase])\n        dictionary = {random.choice(case_type) * 3: random.choice([None, True, False, 'String', 123]) for _ in range(size)}\n        space.append(dictionary)\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/96": [
        "# Import statements\nfrom typing import List, Tuple\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[int], List[int], List[int], List[int]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Base cases - Typical small inputs\n    base = [2, 3, 5, 10, 15, 20, 30, 50, 100]\n    \n    # Corner cases - Edge inputs focusing on boundary conditions\n    corner = [0, 1]  # Testing the smallest n values\n    \n    # Time complexity cases - Large values to test the algorithm's efficiency\n    time = [10000, 20000, 50000]\n    \n    # Space complexity cases - Varied inputs that test different patterns of primes\n    # Generate sequential numbers close to prime dense areas\n    for i in range(1, 26):\n        space.append(1000 * i)\n    \n    # Generate additional base cases\n    for i in range(25):\n        base.append(50 + i)\n    \n    # Generate additional corner cases\n    for i in range(25):\n        corner.append(2**i)  # Powers of two, some are not close to any prime number\n    \n    # Generate additional time complexity cases with more challenging patterns\n    for i in range(22):  # Already have 3 in time, so add 22 more to make 25\n        time.append(10**(5+i%3))\n    \n    # Generate additional space complexity cases\n    for i in range(25):\n        space.append(31 * i)  # Test around different small multipliers of a prime\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/97": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases - Straightforward inputs for normal operation\n    for i in range(25):\n        a = random.randint(0, 99)\n        b = random.randint(0, 99)\n        base.append((a, b))\n\n    # Corner Cases - Limits, edge values, and special returns\n    corner.append((0, 0))  # Both inputs are zero\n    corner.append((0, random.randint(1, 99)))  # One zero input\n    corner.append((random.randint(1, 99), 0))\n    corner.append((-99, random.randint(1, 99)))  # One negative, one positive\n    corner.append((random.randint(1, 99), -99))\n    for i in range(20):\n        a = random.randint(-999, 999)\n        b = random.randint(-999, 999)\n        corner.append((a, b))\n\n    # Time Complexity Cases - Larger inputs to stress the multiplication\n    for i in range(25):\n        a = random.randint(100000, 999999)\n        b = random.randint(100000, 999999)\n        time.append((a, b))\n\n    # Space Complexity Cases - Primarily the same as time complexity cases here\n    for i in range(25):\n        a = random.randint(1000000, 9999999)\n        b = random.randint(1000000, 9999999)\n        space.append((a, b))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/98": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\nimport string\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n    \n    # Helper functions\n    def random_string(length: int) -> str:\n        \"\"\"Generate a random alphabetic string of given length.\"\"\"\n        return ''.join(random.choice(string.ascii_letters) for _ in range(length))\n    \n    def string_with_upper_vowels(length: int) -> str:\n        \"\"\"Generate a string ensuring some uppercase vowels at even indices.\"\"\"\n        s = list(random_string(length))\n        vowels = \"AEIOU\"\n        even_indices = range(0, length, 2)\n        for i in even_indices:\n            if random.choice([True, False]):\n                s[i] = random.choice(vowels)\n        return ''.join(s)\n    \n    # Generate base test cases\n    for _ in range(25):\n        length = random.randint(1, 50)  # moderate length for simplicity\n        s = random_string(length)\n        base.append(s)\n    \n    # Generate corner test cases\n    corner.append(\"\")  # Test with empty string\n    corner.append(\"A\" * 1000)  # Test with all characters as 'A' and maximum length\n    corner.append(\"a\" * 999 + \"E\")  # Test with an uppercase vowel at the last even index in maximum length\n    s = list(\"b\" * 1000)\n    s[998] = \"E\"  # Test with an uppercase vowel at second last even index at maximum length\n    corner.append(\"\".join(s))\n    while len(corner) < 25:\n        length = random.randint(1, 1000)\n        s = string_with_upper_vowels(length)\n        corner.append(s)\n    \n    # Generate time complexity test cases\n    for _ in range(25):\n        length = random.randint(900, 1000)  # near maximum length to test time complexity\n        s = random_string(length)\n        time.append(s)\n    \n    # Generate space complexity test cases\n    for _ in range(25):\n        length = random.randint(900, 1000)  # near maximum length to test space complexity\n        s = random_string(length)\n        space.append(s)\n    \n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ],
    "HumanEval/99": [
        "# Import statements\nfrom typing import List, Tuple, Any\nimport random\n\n# Function to generate test cases\ndef generate_testcases() -> Tuple[List[Any], List[Any], List[Any], List[Any]]:\n    base, corner, time, space = [], [], [], []\n\n    # Base Cases\n    for i in range(25):\n        # Simple integers as strings\n        base.append(str(i))\n        # Simple negative integers as strings\n        base.append(str(-i))\n        # Floating numbers close to integers\n        base.append(str(i + 0.1 * random.choice([-1, 1])))\n        # Floating numbers close to negative integers\n        base.append(str(-i + 0.1 * random.choice([-1, 1])))\n\n    # Corner Cases\n    for i in range(25):\n        # Equidistant floating numbers\n        corner.append(str(i + 0.5))\n        corner.append(str(-i - 0.5))\n        # Small floating numbers\n        corner.append(str(0.1 * random.choice([-1, 1]) * random.random()))\n        # Very close to zero\n        corner.append(str(0.0001 * random.choice([-1, 1])))\n\n    # Time Complexity Cases (large inputs)\n    for i in range(25):\n        # Large floating numbers\n        time.append(str(1e6 * random.random() * random.choice([-1, 1])))\n        # Large integers\n        time.append(str(random.randint(-1000000, 1000000)))\n        # Large equidistant floating numbers\n        time.append(str(1000000 + 0.5))\n        time.append(str(-1000000 - 0.5))\n\n    # Space Complexity Cases (tricky float representations)\n    for i in range(25):\n        # Long decimal places\n        space.append(str(random.choice([-1, 1]) * random.random() * 10 ** random.randint(0, 5)))\n        # Numbers precisely equidistant\n        space.append(str(0.5 + i))\n        space.append(str(-0.5 - i))\n        # Borderline cases for rounding\n        space.append(str(i + 0.4999999))\n        space.append(str(-i - 0.4999999))\n\n    return base, corner, time, space\n\ntestcases = generate_testcases()\n",
        true
    ]
}